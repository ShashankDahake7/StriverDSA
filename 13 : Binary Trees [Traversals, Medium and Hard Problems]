/* Step 13.1: Traversals */

// Number of Nodes		

int numberOfNodes(int N){
    if(N == 0){
        return 0;
    }
    else{
        return pow(2, N- 1);
    }
}

// Binary Tree Representation in C++		

/*
Following is the class structure of the Node class:


class Node
{
public:
    int data;
    Node *left, *right;
    Node(){
        this->data = 0;
        left = NULL;
    }
    Node(int data){
        this->data = data; 
        this->left = NULL;
        this->right = NULL;
    }
    Node(int data, Node* left, Node* right){
        this->data = data;
        this->left = left;
        this->right = right;
    }
};

*/
Node* createtree(vector<int>& arr, int index) {
    // Base case: If index is out of range, or if the element is -1 (indicating a null node)
    if (index >= arr.size() || arr[index] == -1)
        return NULL;
    // Create a new node with the value at the current index
    Node* root = new Node(arr[index]);
    // Recursively create left and right subtrees
    root->left = createtree(arr, 2 * index + 1);
    root->right = createtree(arr, 2 * index + 2);
    return root;
}

Node* createTree(vector<int>&arr){
    return createtree(arr,0);
}

// Binary Tree Traversals in Binary Tree

/*
    Following is Binary Tree Node structure:
    class TreeNode
    {
    public:
        int data;
        TreeNode *left, *right;
        TreeNode() : data(0), left(NULL), right(NULL) {}
        TreeNode(int x) : data(x), left(NULL), right(NULL) {}
        TreeNode(int x, TreeNode *left, TreeNode *right) : data(x), left(left),
   right(right) {}
    };
*/

void Traversal(TreeNode *root, vector<int> &ans1, vector<int> &ans2, vector<int> &ans3) {
    if (root == NULL) {
        return;
    }
    ans2.push_back(root->data);
    Traversal(root->left, ans1, ans2, ans3);
    ans1.push_back(root->data);
    Traversal(root->right, ans1, ans2, ans3);
    ans3.push_back(root->data);
}
vector<vector<int>> getTreeTraversal(TreeNode *root) {
    vector<vector<int>> ans;
    vector<int> ans1, ans2, ans3;
    Traversal(root, ans1, ans2, ans3);
    ans = {ans1, ans2, ans3};
    return ans;
}

// Preorder Traversal of Binary Tree		
	
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    void preorder(TreeNode*&root,vector<int>&pre){
        if(root){
            pre.push_back(root->val);
            preorder(root->left,pre);
            preorder(root->right,pre);
        }
    }
    vector<int> preorderTraversal(TreeNode* root) {
        vector<int> pre;
        preorder(root,pre);
        return pre;
    }
};

// Inorder Traversal of Binary Tree		
	
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left),
 * right(right) {}
 * };
 */
class Solution {
public:
    void inorder(TreeNode* root, vector<int>& ans) {
        if (root != NULL) {
            inorder(root->left, ans);
            ans.push_back(root->val);
            inorder(root->right, ans);
        }
    }
    vector<int> inorderTraversal(TreeNode* root) {
        vector<int> ans;
        inorder(root, ans);
        return ans;
    }
};

// Post-order Traversal of Binary Tree		
	
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left),
 * right(right) {}
 * };
 */
class Solution {
public:
    void postorder(TreeNode* root, vector<int>& ans) {
        if (root != NULL) {
            postorder(root->left, ans);
            postorder(root->right, ans);
            ans.push_back(root->val);
        }
    }
    vector<int> postorderTraversal(TreeNode* root) {
        vector<int> ans;
        postorder(root, ans);
        return ans;
    }
};

// Level order Traversal / Level order traversal in spiral form
	
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<vector<int>> levelOrder(TreeNode* root) {
        vector<vector<int>> ans;
        if(root == NULL){
            return ans;
        }
        queue<TreeNode *> q;
        q.push(root);
        while(!q.empty()){
            int n = q.size();
            vector<int> level;
            for(int i = 0; i < n; i++) {
                TreeNode* front = q.front();
                q.pop();
                level.push_back(front->val);
                if(front->left != NULL){
                    q.push(front->left);
                }
                if(front->right != NULL){
                    q.push(front->right);
                }
            }
            ans.push_back(level);
        }
        return ans;
    }
};

// Iterative Preorder Traversal of Binary Tree		
	
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left),
 * right(right) {}
 * };
 */
class Solution {
public:
    vector<int> preorderTraversal(TreeNode* root) {
        vector<int> ans;
        if (root == NULL) {
            return ans;
        }
        stack<TreeNode*> st;
        st.push(root);
        while (!st.empty()) {
            TreeNode* temp = st.top();
            st.pop();
            ans.push_back(temp->val);
            if (temp->right != NULL) {
                st.push(temp->right);
            }
            if (temp->left != NULL) {
                st.push(temp->left);
            }
        }
        return ans;
    }
};

// Iterative Inorder Traversal of Binary Tree	
	
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left),
 * right(right) {}
 * };
 */
class Solution {
public:
    vector<int> inorderTraversal(TreeNode* root) {
        vector<int> ans;
        stack<TreeNode*> s;
        TreeNode* cur = root;
        while (cur != NULL || !s.empty()) {
            while (cur != NULL) {
                s.push(cur);
                cur = cur->left;
            }
            cur = s.top();
            s.pop();
            ans.push_back(cur->val);
            cur = cur->right;
        }
        return ans;
    }
};

// Post-order Traversal of Binary Tree using 1 stack
	
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left),
 * right(right) {}
 * };
 */
class Solution {
public:
    vector<int> postorderTraversal(TreeNode* root) {
        vector<int> nodes;
        stack<TreeNode*> st;
        TreeNode* last = NULL;
        while (root || !st.empty()) {
            if (root) {
                st.push(root);
                root = root->left;
            } else {
                TreeNode* node = st.top();
                if (node->right && last != node->right) {
                    root = node->right;
                } else {
                    nodes.push_back(node->val);
                    last = node;
                    st.pop();
                }
            }
        }
        return nodes;
    }
};

/* Step 13.2: Medium Problems */

// Height of a Binary Tree		
	
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left),
 * right(right) {}
 * };
 */
class Solution {
public:
    int maxDepth(TreeNode* root) {
        if (root == NULL) {
            return 0;
        }
        int left = maxDepth(root->left);
        int right = maxDepth(root->right);
        int ans = max(left, right) + 1;
        return ans;
    }
};

// Check if the Binary tree is height-balanced or not
	
class Solution {
public:
    int checkBalance(TreeNode* root, bool& ans) {
        if (root == NULL) {
            return 0;
        }
        if (ans == NULL) {
            return 0;
        }
        int leftSubTree = checkBalance(root->left, ans);
        int rightSubTree = checkBalance(root->right, ans);
        if (abs(leftSubTree - rightSubTree) > 1) {
            ans = false;
        }
        return 1 + max(leftSubTree, rightSubTree);
    }
    bool isBalanced(TreeNode* root) {
        bool ans = true;
        checkBalance(root, ans);
        return ans;
    }
};

// Diameter of Binary Tree		
	
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left),
 * right(right) {}
 * };
 */
class Solution {
public:
    int height(TreeNode* root) {
        if (root == NULL) {
            return 0;
        }
        int left = height(root->left);
        int right = height(root->right);
        int ans = max(left, right) + 1;
        return ans;
    }
    int diameterOfBinaryTree(TreeNode* root) {
        if (root == NULL) {
            return 0;
        }
        int height1 = height(root->left);
        int height2 = height(root->right);
        int option1 = height1 + height2;
        int option2 = diameterOfBinaryTree(root->left);
        int option3 = diameterOfBinaryTree(root->right);
        int ans = (max(option1, (max(option2, option3))));
        return ans;
    }
};

// Maximum path sum		
	
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int maxPath(TreeNode* root, int& maxi) {
        if (root == NULL)
            return 0;
        int lh = max(0, maxPath(root->left, maxi));
        int rh = max(0, maxPath(root->right, maxi));
        maxi = max(maxi, lh + rh + root->val);
        return root->val + max(lh, rh);
    }
    int maxPathSum(TreeNode* root) {
        int maxi = INT_MIN;
        maxPath(root, maxi);
        return maxi;
    }
};

// Check if two trees are identical or not
	
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left),
 * right(right) {}
 * };
 */
class Solution {
public:
    bool isSameTree(TreeNode* p, TreeNode* q) {
        if (p == NULL && q == NULL) {
            return true;
        }
        if (p != NULL && q == NULL) {
            return false;
        }
        if (p == NULL && q != NULL) {
            return false;
        }
        if (p->val != q->val) {
            return false;
        } 
        else {
            return (isSameTree(p->left, q->left) && isSameTree(p->right, q->right));
        }
    }
};

// Zig Zag Traversal of Binary Tree		
	
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left),
 * right(right) {}
 * };
 */
class Solution {
public:
    vector<vector<int>> zigzagLevelOrder(TreeNode* root) {
        vector<vector<int>> ans;
        if (root == NULL) {
            return ans;
        }
        queue<TreeNode*> q;
        q.push(root);
        bool leftToRight = true;
        while (!q.empty()) {
            int n = q.size();
            vector<int> level(n);
            for (int i = 0; i < n; i++) {
                TreeNode* t = q.front();
                q.pop();
                int index = leftToRight ? i : n - i - 1;
                level[index] = t->val;
                if (t->left != NULL) {
                    q.push(t->left);
                }
                if (t->right != NULL) {
                    q.push(t->right);
                }
            }
            leftToRight = !leftToRight;
            ans.push_back(level);
        }
        return ans;
    }
};

// Boundary Traversal of Binary Tree		
	
/* A binary tree Node
struct Node
{
    int data;
    Node* left, * right;
}; */
class Solution {
public:
    void traverseLeft(Node* root, vector<int> &ans) {
        // base case
        if((root == NULL) || (root->left == NULL && root->right == NULL))
            return;
        ans.push_back(root->data);
        if(root->left)
            traverseLeft(root->left, ans);
        else
            traverseLeft(root->right, ans);
    }
    void traverseLeaf(Node* root, vector<int> &ans) {
        // base case
        if(root == NULL)
            return;
        if(root->left == NULL && root->right == NULL) {
            ans.push_back(root->data);
            return;
        }
        traverseLeaf(root->left, ans);
        traverseLeaf(root->right, ans);
    }
    void traverseRight(Node* root, vector<int> &ans) {
        // base case
        if((root == NULL) || (root->left == NULL && root->right == NULL))
            return;
        if(root->right)
            traverseRight(root->right, ans);
        else
            traverseRight(root->left, ans);
        // wapas aagye
        ans.push_back(root->data);
    }
    vector <int> boundary(Node *root){
        vector<int> ans;
        if(root == NULL)
            return ans;
        ans.push_back(root->data);
        // left part print/store
        traverseLeft(root->left, ans);
        // traverse Leaf Nodes
        // left subtree
        traverseLeaf(root->left, ans);
        // right subtree
        traverseLeaf(root->right, ans);
        // traverse right part
        traverseRight(root->right, ans);
        return ans;
    }
};

// Vertical Order Traversal of Binary Tree	
	
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left),
 * right(right) {}
 * };
 */
class Solution {
public:
    vector<vector<int>> verticalTraversal(TreeNode* root) {
        map<int, map<int, vector<int>>> nodes; // HD, Level
        queue<pair<TreeNode*, pair<int, int>>> q;
        vector<vector<int>> ans;
        if (root == NULL) {
            return ans;
        }
        q.push(make_pair(root, make_pair(0, 0))); // 0 level pe and 0 distance pe
        while (!q.empty()) {
            pair<TreeNode*, pair<int, int>> temp = q.front();
            q.pop();
            TreeNode* frontNode = temp.first;
            int hd = temp.second.first;
            int lvl = temp.second.second;
            nodes[hd][lvl].push_back(frontNode->val);
            if (frontNode->left) {
                q.push(make_pair(frontNode->left, make_pair(hd - 1, lvl + 1)));
            }
            if (frontNode->right) {
                q.push(make_pair(frontNode->right, make_pair(hd + 1, lvl + 1)));
            }
        }
        for (auto i : nodes) {
            vector<int> output;
            for (auto j : i.second) {
                sort(j.second.begin(), j.second.end()); // extra line added
                for (auto k : j.second) {
                    output.push_back(k);
                }
            }
            ans.push_back(output);
        }
        return ans;
    }
};

// Top View of Binary Tree		
	
class Solution{
    public:
    vector<int> topView(Node *root){
        vector<int> ans;
        if(root == NULL){
            return ans;
        }
        map<int,int> topNode;
        queue<pair<Node*, int> > q;
        q.push(make_pair(root, 0));
        while(!q.empty()) {
            pair<Node*, int> temp = q.front();
            q.pop();
            Node* frontNode = temp.first;
            int hd = temp.second;
            //if one value is present for a HD, then do nothing
            if(topNode.find(hd) == topNode.end())
                topNode[hd] = frontNode -> data;
            if(frontNode->left)
                q.push(make_pair(frontNode->left, hd-1));
            if(frontNode->right)
                q.push(make_pair(frontNode->right, hd+1));
        }
        for(auto i:topNode){
            ans.push_back(i.second);
        }
        return ans;
    }
};

// Bottom View of Binary Tree		
	
class Solution {
  public:
    vector <int> bottomView(Node *root) {
        vector<int> ans;
        if(root == NULL) {
            return ans;
        }
        map<int,int> topNode;
        queue<pair<Node*, int> > q;
        q.push(make_pair(root, 0));
        while(!q.empty()) {
            pair<Node*, int> temp = q.front();
            q.pop();
            Node* frontNode = temp.first;
            int hd = temp.second;
            topNode[hd] = frontNode -> data;
            if(frontNode->left)
                q.push(make_pair(frontNode->left, hd-1));
            if(frontNode->right)
                q.push(make_pair(frontNode->right, hd+1));
        }
        for(auto i:topNode){
            ans.push_back(i.second);
        }
        return ans;
    }
};

// Right/Left View of Binary Tree		
	
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left),
 * right(right) {}
 * };
 */
class Solution {
public:
    void solve(TreeNode* root, vector<int>& ans, int level) {
        // base case
        if (root == NULL) {
            return;
        }
        // we entered into a new level
        if (level == ans.size()) {
            ans.push_back(root->val);
        }
        solve(root->right, ans, level + 1);
        solve(root->left, ans, level + 1);
    }
    vector<int> rightSideView(TreeNode* root) {
        vector<int> ans;
        solve(root, ans, 0);
        return ans;
    }
};

// Symmetric Binary Tree

/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left),
 * right(right) {}
 * };
 */
class Solution {
public:
    bool solve(TreeNode* left, TreeNode* right) {
        if (left == NULL || right == NULL) {
            return left == right;
        }
        if (left->val != right->val) {
            return false;
        }
        return solve(left->left, right->right) && solve(left->right, right->left);
    }
    bool isSymmetric(TreeNode* root) { 
        return solve(root, root); 
    }
};

/* Step 13.3: Hard Problems */

// Root to Node Path in Binary Tree		

/********************************************************************

    Following is the Binary Tree node structure:

    class BinaryTreeNode {
        public :
        int data;
        BinaryTreeNode<T> *left;
        BinaryTreeNode<T> *right;

        BinaryTreeNode(T data) {
            this -> data = data;
            left = NULL;
            right = NULL;
        }
    };
    
********************************************************************/
void solve(BinaryTreeNode<int>* root, vector<string> &ans, string output){
    // Base case
    if(root == NULL)
        return;  
    output += to_string(root->data) + " ";
    if (root->left == NULL && root->right == NULL) {
        ans.push_back(output);
        return;
    }
    solve(root->left, ans, output);
    solve(root->right, ans, output);
}
vector<string> allRootToLeaf(BinaryTreeNode<int> * root) {
    vector<string> ans;
    string output = "";
    solve(root, ans,  output);
    return ans;
}

// LCA in Binary Tree		

/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        // base case
        if (root == NULL) {
            return NULL;
        }
        if (root == p || root == q) {
            return root;
        }
        TreeNode* leftAns = lowestCommonAncestor(root->left, p, q);
        TreeNode* rightAns = lowestCommonAncestor(root->right, p, q);
        if (leftAns != NULL && rightAns != NULL) {
            return root;
        } 
        else if (leftAns == NULL && rightAns != NULL) {
            return rightAns;
        } 
        else if (leftAns != NULL && rightAns == NULL) {
            return leftAns;
        } 
        else {
            return NULL;
        }
    }
};

// Maximum width of a Binary Tree		

// Method-1
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left),
 * right(right) {}
 * };
 */
#define ull unsigned long long
#define um unordered_map
class Solution {
public:
    ull dfs(TreeNode* root, int l, ull i, um<int, ull>& m) {
        // base case
        if (root == NULL)
            return 0;
        // storing the first node in the map at level l
        if (m.find(l) == m.end())
            m[l] = i;
        ull left = dfs(root->left, l + 1, 2 * i, m); // recurse on left subtree
        ull right = dfs(root->right, l + 1, 2 * i + 1, m); // recurse on right subtree
        return max(i - m[l] + 1, max(left, right)); // return max of the difference between first and last index and max of left,right
    }
    int widthOfBinaryTree(TreeNode* root) {
        um<int, ull> f; // storing the last possible index at each level
        return dfs(root, 0, 0, f); // dfs will return you the max width
    }
};

// Method-2
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left),
 * right(right) {}
 * };
 */
class Solution {
public:
    int widthOfBinaryTree(TreeNode* root) {
        if (root == NULL)
            return 0;
        queue<pair<TreeNode*, long long>> q;
        q.push({root, 0});
        long long ans = 0;
        while (q.empty() == false) {
            long long k = q.size();
            long long mmin = q.front().second;
            long long first, last;
            for (long long i = 0; i < k; i++) {
                long long curr_id = q.front().second - mmin;
                TreeNode* curr = q.front().first;
                q.pop();
                if (i == 0)
                    first = curr_id;
                if (i == k - 1)
                    last = curr_id;
                if (curr->left != NULL)
                    q.push({curr->left, curr_id * 2 + 1});
                if (curr->right != NULL)
                    q.push({curr->right, curr_id * 2 + 2});
            }
            ans = max(ans, last - first + 1);
        }
        return ans;
    }
};

// Check for Children Sum Property		

/*
Following is the class structure of the Node class:

class Node
{
public:
    int data;
    Node *left, *right;
    Node()
    {
        this->data = 0;
        left = NULL;
    }
    Node(int data)
    {
        this->data = data; 
        this->left = NULL;
        this->right = NULL;
    }
    Node(int data, Node* left, Node* right)
    {
        this->data = data;
        this->left = left;
        this->right = right;
    }
};
*/

bool isParentSum(Node *root) {
    if (root == NULL) {
        return true;
    }
    if (root->left == NULL && root->right == NULL) {
        return true;
    }
    int leftSum = 0, rightSum = 0;
    if (root->left != NULL) {
        leftSum = root->left->data;
    }
    if (root->right != NULL) {
        rightSum = root->right->data;
    }
    if (root->data != leftSum + rightSum || !isParentSum(root->left) || !isParentSum(root->right)) {
        return false;
    }
    return true;
}

// Print all the Nodes at a distance of K in Binary Tree		
	
// Method-1
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    vector<int> ans;
    unordered_map<TreeNode*, TreeNode*> map;
    void parent(TreeNode* r, TreeNode* p) {
        if (!r)
            return;
        map[r] = p;
        p = r;
        parent(r->left, p);
        parent(r->right, p);
    }
    void below(TreeNode* t, int k) {
        if (!t)
            return;
        if (!k) {
            ans.push_back(t->val);
            return;
        }
        if (t->left)
            below(t->left, k - 1);
        if (t->right)
            below(t->right, k - 1);
    }
    // here we will travel one step up in the tree and find remaining k-1 distant values.
    void above(TreeNode* t, int k) {
        if (!t)
            return;
        if (k == 0) {
            ans.push_back(t->val);
            return;
        }
        // if the value is in left part of parent the we have to find below of
        // right child......and vice versa.
        if (map[t])
            map[t]->left == t ? below(map[t]->right, k - 2) : below(map[t]->left, k - 2);
        // recursion call
        above(map[t], k - 1);
    }
    vector<int> distanceK(TreeNode* root, TreeNode* target, int K) {
        if (!root)
            return ans;
        parent(root, NULL);
        if (K == 0)
            return {target->val};
        below(target, K);
        if (target != root)
            above(target, K);
        return ans;
    }
};

// Method-2
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    void findParent(TreeNode* root, unordered_map<TreeNode*, TreeNode*>& parent_pointer, TreeNode* target) {
        queue<TreeNode*> q;
        q.push(root);
        while (!q.empty()) {
            TreeNode* node = q.front();
            q.pop();
            if (node->left) {
                parent_pointer[node->left] = node;
                q.push(node->left);
            }
            if (node->right) {
                parent_pointer[node->right] = node;
                q.push(node->right);
            }
        }
    }
    void findNodes(unordered_map<TreeNode*, TreeNode*>& parent_pointer, TreeNode* target, vector<int>& ans, int k) {
        queue<TreeNode*> q;
        q.push(target);
        int dist = 0;
        unordered_map<TreeNode*, bool> visited;
        visited[target] = true;
        while (!q.empty()) {
            int size = q.size();
            if (dist++ == k)
                break;
            for (int i = 0; i < size; i++) {
                TreeNode* node = q.front();
                q.pop();
                if (node->left and !visited[node->left]) {
                    q.push(node->left);
                    visited[node->left] = true;
                }
                if (node->right and !visited[node->right]) {
                    q.push(node->right);
                    visited[node->right] = true;
                }
                if (parent_pointer[node] and !visited[parent_pointer[node]]) {
                    q.push(parent_pointer[node]);
                    visited[parent_pointer[node]] = true;
                }
            }
        }
        while (!q.empty()) {
            TreeNode* node = q.front();
            q.pop();
            ans.push_back(node->val);
        }
    }
    vector<int> distanceK(TreeNode* root, TreeNode* target, int k) {
        unordered_map<TreeNode*, TreeNode*> parent_pointer;
        vector<int> ans;
        findParent(root, parent_pointer, target);
        findNodes(parent_pointer, target, ans, k);
        return ans;
    }
};

// Minimum time taken to BURN the Binary Tree from a Node		

/************************************************************

    Following is the Binary Tree node structure

    class BinaryTreeNode 
    {
        public : 
        T data;
        BinaryTreeNode<T> *left;
        BinaryTreeNode<T> *right;

        BinaryTreeNode(T data) 
        {
            this -> data = data;
            left = NULL;
            right = NULL;
        }
    };

************************************************************/

#include<bits/stdc++.h>
using namespace std;
template <typename T>
BinaryTreeNode<T>* createParentMapping(BinaryTreeNode<T>* root, T target, map<BinaryTreeNode<T>*, BinaryTreeNode<T>*>& nodeToParent) {
    BinaryTreeNode<T>* result = NULL;
    queue<BinaryTreeNode<T>*> q;
    q.push(root);
    nodeToParent[root] = NULL;
    while (!q.empty()) {
        BinaryTreeNode<T>* front = q.front();
        q.pop();
        if (front->data == target) {
            result = front;
        }
        if (front->left) {
            nodeToParent[front->left] = front;
            q.push(front->left);
        }
        if (front->right) {
            nodeToParent[front->right] = front;
            q.push(front->right);
        }
    }
    return result;
}

template <typename T>
int burnTree(BinaryTreeNode<T>* root, map<BinaryTreeNode<T>*, BinaryTreeNode<T>*> &nodeToParent) {
    int ans = 0;
    map<BinaryTreeNode<T>*, bool> visited;
    queue<BinaryTreeNode<T>*> q;
    q.push(root);
    visited[root] = true;
    while (!q.empty()) {
        int n = q.size();
        bool flag = false;
        for (int i = 0; i < n; i++) {
            BinaryTreeNode<T>* front = q.front();
            q.pop();
            if (front->left && !visited[front->left]) {
                flag = true;
                q.push(front->left);
                visited[front->left] = true;
            }
            if (front->right && !visited[front->right]) {
                flag = true;
                q.push(front->right);
                visited[front->right] = true;
            }
            if (nodeToParent[front] && !visited[nodeToParent[front]]) {
                flag = true;
                q.push(nodeToParent[front]);
                visited[nodeToParent[front]] = true;
            }
        }
        if (flag == true) {
            ans++;
        }
    }
    return ans;
}

template <typename T>
int timeToBurnTree(BinaryTreeNode<T>* root, T target) {
    int ans = 0;
    map<BinaryTreeNode<T>*, BinaryTreeNode<T>*> nodeToParent;
    BinaryTreeNode<T>* targetNode = createParentMapping(root, target, nodeToParent);
    return burnTree(targetNode, nodeToParent);
}

// Count total Nodes in a COMPLETE Binary Tree	
	
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left),
 * right(right) {}
 * };
 */
class Solution {
public:
    int countNodes(TreeNode* root) {
        if (root == NULL) {
            return 0;
        }
        if (root->left == NULL && root->right == NULL) {
            return 1;
        }
        return 1 + countNodes(root->left) + countNodes(root->right);
    }
};

// Requirements needed to construct a Unique Binary Tree		

int uniqueBinaryTree(int a, int b){
    if(a == 2 && (b == 1 || b == 3)){
        return 1;
    }
    else if((a == 1 || a == 3) && b == 2){
        return 1;
    }
    else{
        return 0;
    }
}

// Construct Binary Tree from inorder ans preorder		
	
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left),
 * right(right) {}
 * };
 */
class Solution {
public:
    TreeNode* build(vector<int>& preorder, vector<int>& inorder, int& rootIdx, int left, int right) {
        if (left > right)
            return NULL;
        int pivot = left; // find the root from inorder
        while (inorder[pivot] != preorder[rootIdx])
            pivot++;
        rootIdx++;
        TreeNode* newNode = new TreeNode(inorder[pivot]);
        newNode->left = build(preorder, inorder, rootIdx, left, pivot - 1);
        newNode->right = build(preorder, inorder, rootIdx, pivot + 1, right);
        return newNode;
    }
    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {
        int rootIdx = 0;
        return build(preorder, inorder, rootIdx, 0, inorder.size() - 1);
    }
};

// Construct the Binary Tree from Postorder and inorder traversal	
	
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left),
 * right(right) {}
 * };
 */
class Solution {
public:
    // p = postorder index, s = inorder start, e = inorder end
    TreeNode* solve(vector<int>& inorder, vector<int>& postorder, int& p, int s, int e) {
        if (p < 0 || s > e || s >= inorder.size() || e < 0) {
            return NULL;
        }
        int x = postorder[p];
        p--;
        auto root = new TreeNode(x);
        if (s == e) {
            return root;
        }
        for (int i = s; i <= e; i++) {
            if (inorder[i] == x) {
                root->right = solve(inorder, postorder, p, i + 1, e);
                root->left = solve(inorder, postorder, p, s, i - 1);
            }
        }
        return root;
    }
    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {
        int p = postorder.size() - 1;
        return solve(inorder, postorder, p, 0, inorder.size() - 1);
    }
};

// Serialize and deserialize Binary Tree
	
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Codec {
public:
    // Encodes a tree to a single string.
    string serialize(TreeNode* root) {
        if (!root) {
            return "NULL,";
        }
        return to_string(root->val) + "," + serialize(root->left) + serialize(root->right);
    }

    // Decodes your encoded data to tree.
    TreeNode* deserialize(string data) {
        queue<string> q;
        string s;
        for (int i = 0; i < data.size(); i++) {
            if (data[i] == ',') {
                q.push(s);
                s = "";
                continue;
            }
            s += data[i];
        }
        if (s.size() != 0)
            q.push(s);
        return deserialize_helper(q);
    }

    TreeNode* deserialize_helper(queue<string>& q) {
        string s = q.front();
        q.pop();
        if (s == "NULL")
            return NULL;
        TreeNode* root = new TreeNode(stoi(s));
        root->left = deserialize_helper(q);
        root->right = deserialize_helper(q);
        return root;
    }
};

// Your Codec object will be instantiated and called as such:
// Codec ser, deser;
// TreeNode* ans = deser.deserialize(ser.serialize(root));

// Morris Preorder Traversal of a Binary Tree		
	
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left),
 * right(right) {}
 * };
 */
class Solution {
public:
    vector<int> preorderTraversal(TreeNode* root) {
        vector<int> ans;
        TreeNode* temp = root;
        while (temp) {
            if (!temp->left) {
                ans.push_back(temp->val);
                temp = temp->right;
            } else {
                TreeNode* prev = temp->left;
                while (prev->right && temp != prev->right) {
                    prev = prev->right;
                }
                if (!prev->right) {
                    prev->right = temp;
                    ans.push_back(temp->val);
                    temp = temp->left;
                } else {
                    prev->right = NULL;
                    temp = temp->right;
                }
            }
        }
        return ans;
    }
};

// Morris Inorder Traversal of a Binary Tree		
	
class Solution {
public:
    vector<int> res;
    vector<int> inorderTraversal(TreeNode* root) {
        // Morris traversal
        if (!root)
            return res;
        TreeNode* curr = root;
        while (curr) {
            if (!curr->left) {
                res.push_back(curr->val);
                curr = curr->right;
            } else {
                TreeNode* temp = curr->left;
                TreeNode* left = curr->left;
                while (temp->right)
                    temp = temp->right;
                temp->right = curr;
                curr->left = nullptr;
                curr = left;
            }
        }
        return res;
    }
};

// Flatten Binary Tree to LinkedList

/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left),
 * right(right) {}
 * };
 */
class Solution {
public:
    void flatten(TreeNode* root) {
        TreeNode* curr = root;
        while (curr != NULL) {
            if (curr->left != NULL) {
                TreeNode* pred = curr->left;
                while (pred->right != NULL) {
                    pred = pred->right;
                }
                pred->right = curr->right;
                curr->right = curr->left;
                curr->left = NULL;
            }
            curr = curr->right;
        }
    }
};
