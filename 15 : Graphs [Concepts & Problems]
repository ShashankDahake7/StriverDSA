/* Step 15.1: Learning */

// Graph and Types		

vector < vector < int >> printAdjacency(int n, int m, vector < vector < int >> & edges) {
    vector<vector<int>> adj(n);
    for(int j = 0; j < n; j++){
        adj[j].push_back(j);
    }
    for(int i = 0; i < m; i++){
        int u = edges[i][0];
        int v = edges[i][1];
        adj[u].push_back(v);
        adj[v].push_back(u);
    }
    return adj;
}

// Graph Representation | C++		

#include <iostream>
using namespace std;
int main(){
    int n, m;
    cin >> n >> m;
    vector<int> adj[n+1];
    for(int i = 0; i < m; i++){
        int u, v;
        // u â€”> v
        cin >> u >> v;
        adj[u].push_back(v);
    }
    return 0;
}

// Counting Graphs

int countingGraphs(int N){
    return pow(2, N * (N - 1) / 2);
}

// Connected Components | Logic Explanation
	
// Method-(DFS-BFS)
class Solution {
  public:
     void bfs(vector<int> adj[],int vis[],int start){
        queue<int> q;
        q.push(start);
        vis[start]=1;
        while(!q.empty()){
            int node=q.front();
            q.pop();
            for(int it:adj[node]){
                if(!vis[it]){
                    vis[it]=1;
                    q.push(it);
                }
            }
        }
    }
    void dfs(vector<int> adj[],int vis[],int start){
        vis[start]=1;
        for(auto it:adj[start]){
            if(!vis[it]){
                dfs(adj,vis,it);
            }
        }
    }
    int numProvinces(vector<vector<int>> adj, int V) {
        vector<int> adj[V];
        for(int i=0;i<V;i++){
            for(int j=0;j<V;j++){
                if(adj[i][j]==1 && i!=j){
                    adj[i].push_back(j);
                    adj[j].push_back(i);
                }
            }
        }
        int vis[V+1];
        for(int i=0;i<V;i++){
            vis[i] = 0;
        }
        int ans=0;
        for(int i=0;i<V;i++){
            if(vis[i]==0){
                ans++;        
                // bfs(adj,vis,i);
                dfs(adj,vis,i);
            }
        }
        return ans;
    }
};

// BFS		
	
class Solution {
  public:
    vector<int> bfsOfGraph(int V, vector<int> adj[]) {
        vector<int> ans;
        vector<int> vis(V, 0);
        queue<int> q;
        q.push(0);
        vis[0] = 1;
        while(!q.empty()){
            int f = q.front();
            q.pop();
            ans.push_back(f);
            for(auto &it : adj[f]){
                if(!vis[it]){
                    q.push(it);
                    vis[it]=1;
                }
            }
        }
        return ans;
    }
};

// DFS		

class Solution {
  public:
    // Function to return a list containing the DFS traversal of the graph.
    void dfs(int i, vector<int>& vis, vector<int>& ans, vector<int> adj[]){
        vis[i] = 1;
        ans.push_back(i);
        for(auto &it: adj[i]){
            if(!vis[it]){
                dfs(it, vis, ans, adj);
            }
        }
    }
    vector<int> dfsOfGraph(int V, vector<int> adj[]) {
        vector<int> ans;
        vector<int> vis(V, 0);
        dfs(0, vis, ans, adj);
        return ans;
    }
};

/* Step 15.2: Problems on BFS/DFS */

// Number of provinces

// Method-1
class Solution {
public:
    void dfs(vector<int>& vis, vector<vector<int>> adj, int i) {
        vis[i] = 1;
        for (auto i : adj[i]) {
            if (vis[i] == 0) {
                vis[i] = 1;
                dfs(vis, adj, i);
            }
        }
    }
    int findCircleNum(vector<vector<int>>& num) {
        int n = num.size();
        vector<vector<int>> adj(n);
        for (int i = 0; i < num.size(); i++) {
            for (int j = 0; j < num[i].size(); j++) {
                if (i != j && num[i][j] == 1) {
                    adj[i].push_back(j);
                }
            }
        }
        vector<int> vis(n, 0);
        int count = 0;
        for (int i = 0; i < n; i++) {
            if (!vis[i]) {
                dfs(vis, adj, i);
                count++;
            }
        }
        return count;
    }
};

// Method-2
class Solution {
public:
    void bfs(vector<int>& vis, vector<vector<int>> adj, int i) {
        queue<int> q;
        q.push(i);
        vis[i] = 1;
        while(!q.empty()){
            int f = q.front();
            q.pop();
            for(auto x : adj[f]){
                if(!vis[x]){
                    vis[x] = 1;
                    q.push(x);
                }
            }
        }
    }
    int findCircleNum(vector<vector<int>>& num) {
        int n = num.size();
        vector<vector<int>> adj(n);
        for (int i = 0; i < num.size(); i++) {
            for (int j = 0; j < num[i].size(); j++) {
                if (i != j && num[i][j] == 1) {
                    adj[i].push_back(j);
                }
            }
        }
        vector<int> vis(n, 0);
        int count = 0;
        for (int i = 0; i < n; i++) {
            if (!vis[i]) {
                count++;
                bfs(vis, adj, i);
            }
        }
        return count;
    }
};

// Connected Components Problem in Matrix			

// Method-1
class Solution {
public:
    void dfs(vector<int>& vis, vector<vector<int>> adj, int i) {
        vis[i] = 1;
        for (auto i : adj[i]) {
            if (vis[i] == 0) {
                vis[i] = 1;
                dfs(vis, adj, i);
            }
        }
    }
    int findCircleNum(vector<vector<int>>& num) {
        int n = num.size();
        vector<vector<int>> adj(n);
        for (int i = 0; i < num.size(); i++) {
            for (int j = 0; j < num[i].size(); j++) {
                if (i != j && num[i][j] == 1) {
                    adj[i].push_back(j);
                }
            }
        }
        vector<int> vis(n, 0);
        int count = 0;
        for (int i = 0; i < n; i++) {
            if (!vis[i]) {
                dfs(vis, adj, i);
                count++;
            }
        }
        return count;
    }
};

// Method-2
class Solution {
public:
    void bfs(vector<int>& vis, vector<vector<int>> adj, int i) {
        queue<int> q;
        q.push(i);
        vis[i] = 1;
        while(!q.empty()){
            int f = q.front();
            q.pop();
            for(auto x : adj[f]){
                if(!vis[x]){
                    vis[x] = 1;
                    q.push(x);
                }
            }
        }
    }
    int findCircleNum(vector<vector<int>>& num) {
        int n = num.size();
        vector<vector<int>> adj(n);
        for (int i = 0; i < num.size(); i++) {
            for (int j = 0; j < num[i].size(); j++) {
                if (i != j && num[i][j] == 1) {
                    adj[i].push_back(j);
                }
            }
        }
        vector<int> vis(n, 0);
        int count = 0;
        for (int i = 0; i < n; i++) {
            if (!vis[i]) {
                count++;
                bfs(vis, adj, i);
            }
        }
        return count;
    }
};

// Rotten Oranges		
	
class Solution {
public:
    int orangesRotting(vector<vector<int>>& grid) {
        int m = grid.size();
        int n = grid[0].size();
        vector<vector<int>> visited = grid;
        queue<pair<int, int>> q;
        int countFreshOrange = 0;
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (visited[i][j] == 2) {
                    q.push({i, j});
                }
                if (visited[i][j] == 1) {
                    countFreshOrange++;
                }
            }
        }
        // q.empty() means there is no rotten orange in the grid and
        // countFreshOrange = 0 means we will rotten the freshoranges in 0 mins
        if (countFreshOrange == 0)
            return 0;
        if (q.empty())
            return -1;
        int minutes = -1;
        // we will cover four directions i.e. up, down, left, right
        vector<pair<int, int>> dirs = {{1, 0}, {-1, 0}, {0, -1}, {0, 1}};
        while (!q.empty()) {
            int size = q.size();
            while (size--) {
                auto [x, y] = q.front();
                q.pop();
                for (auto [dx, dy] : dirs) {
                    int i = x + dx;
                    int j = y + dy;
                    if (i >= 0 && i < m && j >= 0 && j < n && visited[i][j] == 1) {
                        visited[i][j] = 2;
                        countFreshOrange--;
                        q.push({i, j});
                    }
                }
            }
            minutes++;
        }
        if (countFreshOrange == 0)
            return minutes;
        return -1;
    }
};

// Flood fill		
	
class Solution {
public:
    void dfs(vector<vector<int>>& image, int i, int j, int val, int newColor) {
        if (i < 0 || i >= image.size() || j < 0 || j >= image[0].size() || image[i][j] == newColor || image[i][j] != val) {
            return;
        }
        image[i][j] = newColor;
        dfs(image, i - 1, j, val, newColor);
        dfs(image, i + 1, j, val, newColor);
        dfs(image, i, j - 1, val, newColor);
        dfs(image, i, j + 1, val, newColor);
    }
    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int newColor) {
        int val = image[sr][sc];
        dfs(image, sr, sc, val, newColor);
        return image;
    }
};

// Cycle Detection in unirected Graph (BFS)

class Graph {
private:
    bool checkForCycle(int s, int V, vector<int> adj[], vector<int>& visited) {
        vector<int> parent(V, -1);
        queue<pair<int, int>> q;
        visited[s] = true;
        q.push({s, -1});
        while (!q.empty()) {
            int node = q.front().first;
            int par = q.front().second;
            q.pop();
            for (auto it : adj[node]) {
                if (!visited[it]) {
                    visited[it] = true;
                    q.push({it, node});
                } else if (par != it) {
                    return true;
                }
            }
        }
        return false;
    }
public:
    bool detectCycle(int V, vector<int> adj[]) {
        vector<int> vis(V, 0);
        for (int i = 0; i < V; i++) {
            if (!vis[i]) {
                if (checkForCycle(i, V, adj, vis)) 
                    return true;
            }
        }
        return false;
    }
};


// Cycle Detection in undirected Graph (DFS)

class Graph {
private:
    bool dfs(int node, int parent, int vis[], vector<int> adj[]){
        vis[node] = 1;
        for(auto i : adj[node]){
            if(!vis[i]){
                if(dfs(i, node, vis, adj)) 
                    return true;
            }
            else if(i != parent) 
                return true;
        }
        return false;
    }
public:
    bool detectCycle(int V, vector<int> adj[]) {
        int vis[V] = { 0 };
        for(int i = 0; i < V; i++){
            if(!vis[i]){
                if(dfs(i, -1, vis, adj)) 
                    return true;
            }
        }
        return false;
    }
};

// 0/1 Matrix (Bfs Problem)		
	
class Solution {
public:
    vector<vector<int>> updateMatrix(vector<vector<int>>& mat) {
        int m = mat.size();
        int n = mat[0].size();
        vector<vector<int>> res(m, vector<int> (n, -1));
        queue<pair<int, int>> q;
        for(int i = 0; i < m; i++){
            for(int j = 0; j < n; j++){
                if(mat[i][j] == 0){
                    res[i][j] = 0;
                    q.push({i, j});
                }
            }
        }
        vector<vector<int>> dir = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};
        while(!q.empty()){
            pair<int, int> p = q.front();
            q.pop();
            int i = p.first;
            int j = p.second;
            for(auto &d : dir){
                int new_i = i + d[0];
                int new_j = j + d[1];
                if(new_i >=0 && new_i < m && new_j >= 0 && new_j < n && res[new_i][new_j] == -1){
                    res[new_i][new_j] = res[i][j] + 1;
                    q.push({new_i, new_j});
                }
            }
        }
        return res;
    }
};

// Surrounded Regions (dfs)		
	
class Solution {
public:
    void dfs(vector<vector<char>>& board, int i, int j, bool& flip, vector<vector<bool>>& visited) {
        if (i >= 0 && i < board.size() && j >= 0 && j < board[0].size() && !visited[i][j]) {
            visited[i][j] = true;
            if (i == 0 || i == board.size() - 1 || j == 0 || j == board[0].size() - 1) {
                if (board[i][j] != 'X') {
                    flip = false;
                }
            }
            if (board[i][j] != 'O') {
                return;
            }
            dfs(board, i - 1, j, flip, visited);
            dfs(board, i + 1, j, flip, visited);
            dfs(board, i, j - 1, flip, visited);
            dfs(board, i, j + 1, flip, visited);
        }
    }
    void fill(vector<vector<char>>& board, int i, int j) {
        if (i >= 0 && i < board.size() && j >= 0 && j < board[i].size() && board[i][j] != 'X') {
            board[i][j] = 'X';
            fill(board, i - 1, j);
            fill(board, i + 1, j);
            fill(board, i, j - 1);
            fill(board, i, j + 1);
        }
    }
    void solve(vector<vector<char>>& board) {
        for (int i = 1; i < board.size() - 1; i++) {
            for (int j = 1; j < board[i].size() - 1; j++) {
                if (board[i][j] == 'O') {
                    bool flip = true;
                    vector<vector<bool>> visited(board.size(), vector<bool>(board[0].size(), false));
                    dfs(board, i, j, flip, visited);
                    if (flip) {
                        fill(board, i, j);
                    }
                }
            }
        }
    }
};

// Number of Enclaves [flood fill implementation-multisource)		
	
class Solution {
public:
    bool isValid(int i, int j, int m, int n, vector<vector<int>>& grid){
        if(i >= 0 && i < m && j >= 0 && j < n && grid[i][j] == 1){
            return true;
        }
        return false;
    }
    void dfs(int i, int j, int m, int n, vector<vector<int>>& grid){
        grid[i][j] = 0;
        vector<vector<int>> dir = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};
        for(auto &d : dir){
            int new_i = i + d[0];
            int new_j = j + d[1];
            if(isValid(new_i, new_j, m, n, grid)){
                dfs(new_i, new_j, m, n, grid);
            }
        }
    }
    int numEnclaves(vector<vector<int>>& grid) {
        int m = grid.size();
        int n = grid[0].size();
        for(int i = 0; i < m; i++){
            for(int j = 0; j < n; j++){
                if((i == 0 || i == m - 1 || j == 0 || j == n - 1) && grid[i][j] == 1){
                    dfs(i, j, m, n, grid);
                }
            }
        }
        int ans = 0;
        for(int i = 0; i < m; i++){
            for(int j = 0; j < n; j++){
                if(grid[i][j] == 1){
                    ans++;
                }
            }
        }
        return ans;
    }
};

// Word ladder - 1		
	
class Solution {
public:
    int ladderLength(string beginWord, string endWord, vector<string>& wordList) {
        queue<pair<string, int>> q;
        q.push({beginWord, 1});
        unordered_set<string> st(wordList.begin(), wordList.end());
        st.erase(beginWord);
        while(!q.empty()){
            string word = q.front().first;
            int steps = q.front().second;
            q.pop();
            if(word == endWord){
                return steps;
            }
            for(int i = 0; i < word.size(); i++){
                char original = word[i];
                for(char ch = 'a'; ch <= 'z'; ch++){
                    word[i] = ch;
                    if(st.find(word) !=st.end()){
                        st.erase(word);
                        q.push({word, steps + 1});
                    }
                }
                word[i] = original;
            }
        }
        return 0;
    }
};

// Word ladder - 2		
	


// Number of Distinct Islands [dfs multisource]



// Bipartite Graph (DFS)		
	


// Cycle Detection in Directed Graph (DFS)



/* Step 15.3: Topo Sort and Problems */

// Topo Sort		



// Kahn's Algorithm		



// Cycle Detection in Directed Graph (BFS)



// Course Schedule - I		
	


// Course Schedule - II		
	


// Find eventual safe states		
	


// Alien dictionary		
	


/* Step 15.4: Shortest Path Algorithms and Problems */

// Shortest Path in UG with unit weights



// Shortest Path in DAG		



// Djisktra's Algorithm		



// Why priority Queue is used in Djisktra Algorithm		



// Shortest path in a binary maze		
	


// Path with minimum effort		
	


// Cheapest flights within k stops		
	


// Network Delay time				



// Number of ways to arrive at destination		
	


// Minimum multiplications to reach end		



// Bellman Ford Algorithm		



// Floyd Warshal Algorithm		



// Find the city with the smallest number of neighbours in a threshold distance		



/* Step 15.5: MinimumSpanningTree/Disjoint Set and Problems */

// Minimum Spanning Tree		



// Prim's Algorithm		



// Disjoint Set [Union by Rank]		



// Disjoint Set [Union by Size]		



// Kruskal's Algorithm		



// Number of operations to make network connected		
	


// Most stones removed with same rows or columns



// Accounts merge		
	


// Number of island II		
	


// Making a Large Island		
	


// Swim in rising water				



/* Step 15.6: Other Algorithms */

// Bridges in Graph		
	


// Articulation Point		



// Kosaraju's Algorithm		

