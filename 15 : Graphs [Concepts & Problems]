/* Step 15.1: Learning */

// Graph and Types		

vector < vector < int >> printAdjacency(int n, int m, vector < vector < int >> & edges) {
    vector<vector<int>> adj(n);
    for(int j = 0; j < n; j++){
        adj[j].push_back(j);
    }
    for(int i = 0; i < m; i++){
        int u = edges[i][0];
        int v = edges[i][1];
        adj[u].push_back(v);
        adj[v].push_back(u);
    }
    return adj;
}

// Graph Representation | C++		

#include <iostream>
using namespace std;
int main(){
    int n, m;
    cin >> n >> m;
    vector<int> adj[n+1];
    for(int i = 0; i < m; i++){
        int u, v;
        // u â€”> v
        cin >> u >> v;
        adj[u].push_back(v);
    }
    return 0;
}

// Counting Graphs

int countingGraphs(int N){
    return pow(2, N * (N - 1) / 2);
}

// Connected Components | Logic Explanation
	
// Method-(DFS-BFS)
class Solution {
  public:
     void bfs(vector<int> adj[],int vis[],int start){
        queue<int> q;
        q.push(start);
        vis[start]=1;
        while(!q.empty()){
            int node=q.front();
            q.pop();
            for(int it:adj[node]){
                if(!vis[it]){
                    vis[it]=1;
                    q.push(it);
                }
            }
        }
    }
    void dfs(vector<int> adj[],int vis[],int start){
        vis[start]=1;
        for(auto it:adj[start]){
            if(!vis[it]){
                dfs(adj,vis,it);
            }
        }
    }
    int numProvinces(vector<vector<int>> adj, int V) {
        vector<int> adj[V];
        for(int i=0;i<V;i++){
            for(int j=0;j<V;j++){
                if(adj[i][j]==1 && i!=j){
                    adj[i].push_back(j);
                    adj[j].push_back(i);
                }
            }
        }
        int vis[V+1];
        for(int i=0;i<V;i++){
            vis[i] = 0;
        }
        int ans=0;
        for(int i=0;i<V;i++){
            if(vis[i]==0){
                ans++;        
                // bfs(adj,vis,i);
                dfs(adj,vis,i);
            }
        }
        return ans;
    }
};

// BFS		
	
class Solution {
  public:
    vector<int> bfsOfGraph(int V, vector<int> adj[]) {
        vector<int> ans;
        vector<int> vis(V, 0);
        queue<int> q;
        q.push(0);
        vis[0] = 1;
        while(!q.empty()){
            int f = q.front();
            q.pop();
            ans.push_back(f);
            for(auto &it : adj[f]){
                if(!vis[it]){
                    q.push(it);
                    vis[it]=1;
                }
            }
        }
        return ans;
    }
};

// DFS		

class Solution {
  public:
    // Function to return a list containing the DFS traversal of the graph.
    void dfs(int i, vector<int>& vis, vector<int>& ans, vector<int> adj[]){
        vis[i] = 1;
        ans.push_back(i);
        for(auto &it: adj[i]){
            if(!vis[it]){
                dfs(it, vis, ans, adj);
            }
        }
    }
    vector<int> dfsOfGraph(int V, vector<int> adj[]) {
        vector<int> ans;
        vector<int> vis(V, 0);
        dfs(0, vis, ans, adj);
        return ans;
    }
};

/* Step 15.2: Problems on BFS/DFS */

// Number of provinces

// Method-1
class Solution {
public:
    void dfs(vector<int>& vis, vector<vector<int>> adj, int i) {
        vis[i] = 1;
        for (auto i : adj[i]) {
            if (vis[i] == 0) {
                vis[i] = 1;
                dfs(vis, adj, i);
            }
        }
    }
    int findCircleNum(vector<vector<int>>& num) {
        int n = num.size();
        vector<vector<int>> adj(n);
        for (int i = 0; i < num.size(); i++) {
            for (int j = 0; j < num[i].size(); j++) {
                if (i != j && num[i][j] == 1) {
                    adj[i].push_back(j);
                }
            }
        }
        vector<int> vis(n, 0);
        int count = 0;
        for (int i = 0; i < n; i++) {
            if (!vis[i]) {
                dfs(vis, adj, i);
                count++;
            }
        }
        return count;
    }
};

// Method-2
class Solution {
public:
    void bfs(vector<int>& vis, vector<vector<int>> adj, int i) {
        queue<int> q;
        q.push(i);
        vis[i] = 1;
        while(!q.empty()){
            int f = q.front();
            q.pop();
            for(auto x : adj[f]){
                if(!vis[x]){
                    vis[x] = 1;
                    q.push(x);
                }
            }
        }
    }
    int findCircleNum(vector<vector<int>>& num) {
        int n = num.size();
        vector<vector<int>> adj(n);
        for (int i = 0; i < num.size(); i++) {
            for (int j = 0; j < num[i].size(); j++) {
                if (i != j && num[i][j] == 1) {
                    adj[i].push_back(j);
                }
            }
        }
        vector<int> vis(n, 0);
        int count = 0;
        for (int i = 0; i < n; i++) {
            if (!vis[i]) {
                count++;
                bfs(vis, adj, i);
            }
        }
        return count;
    }
};

// Connected Components Problem in Matrix			

// Method-1
class Solution {
public:
    void dfs(vector<int>& vis, vector<vector<int>> adj, int i) {
        vis[i] = 1;
        for (auto i : adj[i]) {
            if (vis[i] == 0) {
                vis[i] = 1;
                dfs(vis, adj, i);
            }
        }
    }
    int findCircleNum(vector<vector<int>>& num) {
        int n = num.size();
        vector<vector<int>> adj(n);
        for (int i = 0; i < num.size(); i++) {
            for (int j = 0; j < num[i].size(); j++) {
                if (i != j && num[i][j] == 1) {
                    adj[i].push_back(j);
                }
            }
        }
        vector<int> vis(n, 0);
        int count = 0;
        for (int i = 0; i < n; i++) {
            if (!vis[i]) {
                dfs(vis, adj, i);
                count++;
            }
        }
        return count;
    }
};

// Method-2
class Solution {
public:
    void bfs(vector<int>& vis, vector<vector<int>> adj, int i) {
        queue<int> q;
        q.push(i);
        vis[i] = 1;
        while(!q.empty()){
            int f = q.front();
            q.pop();
            for(auto x : adj[f]){
                if(!vis[x]){
                    vis[x] = 1;
                    q.push(x);
                }
            }
        }
    }
    int findCircleNum(vector<vector<int>>& num) {
        int n = num.size();
        vector<vector<int>> adj(n);
        for (int i = 0; i < num.size(); i++) {
            for (int j = 0; j < num[i].size(); j++) {
                if (i != j && num[i][j] == 1) {
                    adj[i].push_back(j);
                }
            }
        }
        vector<int> vis(n, 0);
        int count = 0;
        for (int i = 0; i < n; i++) {
            if (!vis[i]) {
                count++;
                bfs(vis, adj, i);
            }
        }
        return count;
    }
};

// Rotten Oranges		
	
class Solution {
public:
    int orangesRotting(vector<vector<int>>& grid) {
        int m = grid.size();
        int n = grid[0].size();
        vector<vector<int>> visited = grid;
        queue<pair<int, int>> q;
        int countFreshOrange = 0;
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (visited[i][j] == 2) {
                    q.push({i, j});
                }
                if (visited[i][j] == 1) {
                    countFreshOrange++;
                }
            }
        }
        // q.empty() means there is no rotten orange in the grid and
        // countFreshOrange = 0 means we will rotten the freshoranges in 0 mins
        if (countFreshOrange == 0)
            return 0;
        if (q.empty())
            return -1;
        int minutes = -1;
        // we will cover four directions i.e. up, down, left, right
        vector<pair<int, int>> dirs = {{1, 0}, {-1, 0}, {0, -1}, {0, 1}};
        while (!q.empty()) {
            int size = q.size();
            while (size--) {
                auto [x, y] = q.front();
                q.pop();
                for (auto [dx, dy] : dirs) {
                    int i = x + dx;
                    int j = y + dy;
                    if (i >= 0 && i < m && j >= 0 && j < n && visited[i][j] == 1) {
                        visited[i][j] = 2;
                        countFreshOrange--;
                        q.push({i, j});
                    }
                }
            }
            minutes++;
        }
        if (countFreshOrange == 0)
            return minutes;
        return -1;
    }
};

// Flood fill		
	
class Solution {
public:
    void dfs(vector<vector<int>>& image, int i, int j, int val, int newColor) {
        if (i < 0 || i >= image.size() || j < 0 || j >= image[0].size() || image[i][j] == newColor || image[i][j] != val) {
            return;
        }
        image[i][j] = newColor;
        dfs(image, i - 1, j, val, newColor);
        dfs(image, i + 1, j, val, newColor);
        dfs(image, i, j - 1, val, newColor);
        dfs(image, i, j + 1, val, newColor);
    }
    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int newColor) {
        int val = image[sr][sc];
        dfs(image, sr, sc, val, newColor);
        return image;
    }
};

// Cycle Detection in unirected Graph (BFS)

class Graph {
private:
    bool checkForCycle(int s, int V, vector<int> adj[], vector<int>& visited) {
        vector<int> parent(V, -1);
        queue<pair<int, int>> q;
        visited[s] = true;
        q.push({s, -1});
        while (!q.empty()) {
            int node = q.front().first;
            int par = q.front().second;
            q.pop();
            for (auto it : adj[node]) {
                if (!visited[it]) {
                    visited[it] = true;
                    q.push({it, node});
                } else if (par != it) {
                    return true;
                }
            }
        }
        return false;
    }
public:
    bool detectCycle(int V, vector<int> adj[]) {
        vector<int> vis(V, 0);
        for (int i = 0; i < V; i++) {
            if (!vis[i]) {
                if (checkForCycle(i, V, adj, vis)) 
                    return true;
            }
        }
        return false;
    }
};


// Cycle Detection in undirected Graph (DFS)

class Graph {
private:
    bool dfs(int node, int parent, int vis[], vector<int> adj[]){
        vis[node] = 1;
        for(auto i : adj[node]){
            if(!vis[i]){
                if(dfs(i, node, vis, adj)) 
                    return true;
            }
            else if(i != parent) 
                return true;
        }
        return false;
    }
public:
    bool detectCycle(int V, vector<int> adj[]) {
        int vis[V] = { 0 };
        for(int i = 0; i < V; i++){
            if(!vis[i]){
                if(dfs(i, -1, vis, adj)) 
                    return true;
            }
        }
        return false;
    }
};

// 0/1 Matrix (Bfs Problem)		
	
class Solution {
public:
    vector<vector<int>> updateMatrix(vector<vector<int>>& mat) {
        int m = mat.size();
        int n = mat[0].size();
        vector<vector<int>> res(m, vector<int> (n, -1));
        queue<pair<int, int>> q;
        for(int i = 0; i < m; i++){
            for(int j = 0; j < n; j++){
                if(mat[i][j] == 0){
                    res[i][j] = 0;
                    q.push({i, j});
                }
            }
        }
        vector<vector<int>> dir = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};
        while(!q.empty()){
            pair<int, int> p = q.front();
            q.pop();
            int i = p.first;
            int j = p.second;
            for(auto &d : dir){
                int new_i = i + d[0];
                int new_j = j + d[1];
                if(new_i >=0 && new_i < m && new_j >= 0 && new_j < n && res[new_i][new_j] == -1){
                    res[new_i][new_j] = res[i][j] + 1;
                    q.push({new_i, new_j});
                }
            }
        }
        return res;
    }
};

// Surrounded Regions (dfs)		
	
class Solution {
public:
    void dfs(vector<vector<char>>& board, int i, int j, bool& flip, vector<vector<bool>>& visited) {
        if (i >= 0 && i < board.size() && j >= 0 && j < board[0].size() && !visited[i][j]) {
            visited[i][j] = true;
            if (i == 0 || i == board.size() - 1 || j == 0 || j == board[0].size() - 1) {
                if (board[i][j] != 'X') {
                    flip = false;
                }
            }
            if (board[i][j] != 'O') {
                return;
            }
            dfs(board, i - 1, j, flip, visited);
            dfs(board, i + 1, j, flip, visited);
            dfs(board, i, j - 1, flip, visited);
            dfs(board, i, j + 1, flip, visited);
        }
    }
    void fill(vector<vector<char>>& board, int i, int j) {
        if (i >= 0 && i < board.size() && j >= 0 && j < board[i].size() && board[i][j] != 'X') {
            board[i][j] = 'X';
            fill(board, i - 1, j);
            fill(board, i + 1, j);
            fill(board, i, j - 1);
            fill(board, i, j + 1);
        }
    }
    void solve(vector<vector<char>>& board) {
        for (int i = 1; i < board.size() - 1; i++) {
            for (int j = 1; j < board[i].size() - 1; j++) {
                if (board[i][j] == 'O') {
                    bool flip = true;
                    vector<vector<bool>> visited(board.size(), vector<bool>(board[0].size(), false));
                    dfs(board, i, j, flip, visited);
                    if (flip) {
                        fill(board, i, j);
                    }
                }
            }
        }
    }
};

// Number of Enclaves [flood fill implementation-multisource)		
	
class Solution {
public:
    bool isValid(int i, int j, int m, int n, vector<vector<int>>& grid){
        if(i >= 0 && i < m && j >= 0 && j < n && grid[i][j] == 1){
            return true;
        }
        return false;
    }
    void dfs(int i, int j, int m, int n, vector<vector<int>>& grid){
        grid[i][j] = 0;
        vector<vector<int>> dir = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};
        for(auto &d : dir){
            int new_i = i + d[0];
            int new_j = j + d[1];
            if(isValid(new_i, new_j, m, n, grid)){
                dfs(new_i, new_j, m, n, grid);
            }
        }
    }
    int numEnclaves(vector<vector<int>>& grid) {
        int m = grid.size();
        int n = grid[0].size();
        for(int i = 0; i < m; i++){
            for(int j = 0; j < n; j++){
                if((i == 0 || i == m - 1 || j == 0 || j == n - 1) && grid[i][j] == 1){
                    dfs(i, j, m, n, grid);
                }
            }
        }
        int ans = 0;
        for(int i = 0; i < m; i++){
            for(int j = 0; j < n; j++){
                if(grid[i][j] == 1){
                    ans++;
                }
            }
        }
        return ans;
    }
};

// Word ladder - 1		
	
class Solution {
public:
    int ladderLength(string beginWord, string endWord, vector<string>& wordList) {
        queue<pair<string, int>> q;
        q.push({beginWord, 1});
        unordered_set<string> st(wordList.begin(), wordList.end());
        st.erase(beginWord);
        while(!q.empty()){
            string word = q.front().first;
            int steps = q.front().second;
            q.pop();
            if(word == endWord){
                return steps;
            }
            for(int i = 0; i < word.size(); i++){
                char original = word[i];
                for(char ch = 'a'; ch <= 'z'; ch++){
                    word[i] = ch;
                    if(st.find(word) !=st.end()){
                        st.erase(word);
                        q.push({word, steps + 1});
                    }
                }
                word[i] = original;
            }
        }
        return 0;
    }
};

// Word ladder - 2		
	
class Solution {
public:
    vector<vector<string>> ans;
    void DFS(string &beginWord, string &endWord, unordered_map<string, unordered_set<string>>&adj, vector<string>&path){
        path.push_back(beginWord);
        if(beginWord == endWord){
            ans.push_back(path);
            path.pop_back();
            return;
        }
        for(auto x : adj[beginWord])
            DFS(x, endWord, adj, path);
        
        path.pop_back(); //pop current word to backtrack
    }
    vector<vector<string>> findLadders(string beginWord, string endWord, vector<string>& wordList) {
        unordered_map<string,unordered_set<string>>adj; //adjacency list
        unordered_set<string> dict(wordList.begin(), wordList.end()); //insert all the strings in set
        
		//step-1 => Find min depth using BFS
        queue<string>q;  //for BFS Traversal
        q.push(beginWord);
        unordered_map<string,int>visited;
        visited[beginWord] = 0; //start node will always at level 0
        
        while(!q.empty()){
            string curr = q.front();
            q.pop();
            string temp = curr;
            
            for(int i = 0; i < curr.size(); i++){ //check all characters
                for(char c = 'a'; c <= 'z'; c++){ //try all possible 26 letters
                    if(temp[i] == c) continue;  //skip if letter is same as original word
                    temp[i] = c;
                    
                    if(dict.count(temp) > 0){ // check if new word is present in wordList
                        if(visited.count(temp) == 0){ //check if new word was already visited
                            visited[temp] = visited[curr] + 1;
                            q.push(temp);
                            adj[curr].insert(temp);
                        }
                        else if(visited[temp] == visited[curr] + 1) //if already visited and new word is child
                            adj[curr].insert(temp);    
                    }
                }
                temp[i] = curr[i];  //revert back temp to curr
            }
        }
       // step-2 => find all min depth possible paths using DFS
        vector<string>path;
        DFS(beginWord, endWord, adj, path);
        return ans;
    }
};

// Number of Distinct Islands [dfs multisource]

class Solution {
public:
    bool isvalid(int i, int j, int n, int m) {
        return i >= 0 && i < n && j >= 0 && j < m;
    }
    vector<pair<int, int>> moves = {{1, 0}, {0, 1}, {-1, 0}, {0, -1}};
    void dfs(int i, int j, vector<vector<int>>& grid, vector<vector<int>>& vis, vector<pair<int, int>>& ar, int x, int y) {
        int n = grid.size();
        int m = grid[0].size();
        vis[i][j] = 1;
        ar.push_back({i - x, j - y});
        for (auto child : moves) {
            int p = i + child.first;
            int q = j + child.second;
            if (!isvalid(p, q, n, m))
                continue;
            if (grid[p][q] == 0)
                continue;
            if (!vis[p][q]) {
                dfs(p, q, grid, vis, ar, x, y);
            }
        }
    }
    int countDistinctIslands(vector<vector<int>>& grid) {
        int n = grid.size();
        int m = grid[0].size();
        vector<vector<int>> vis(n, vector<int>(m, 0));
        set<vector<pair<int, int>>> s;
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                if (!vis[i][j] && grid[i][j] == 1) {
                    vector<pair<int, int>> ar;
                    dfs(i, j, grid, vis, ar, i, j);
                    s.insert(ar);
                }
            }
        }
        return s.size();
    }
};

// Bipartite Graph
	
// BFS
class Solution {
public:
    bool bfs(int node, vector<vector<int>>& graph, vector<int>& color, vector<int>& vis) {
        queue<int> q;
        q.push(node);
        vis[node] = 1;
        color[node] = 1;
        while (!q.empty()) {
            int curr = q.front();
            q.pop();
            for (int i = 0; i < graph[curr].size(); i++) {
                int adjNode = graph[curr][i];
                if (!vis[adjNode]) {
                    if (color[curr] == color[adjNode]) {
                        color[adjNode] = (-1 * color[curr]);
                    }
                    vis[adjNode] = 1;
                    q.push(adjNode);
                }
                if (vis[adjNode] && color[adjNode] == color[curr])
                    return false;
                }
        }
        return true;
    }
    bool isBipartite(vector<vector<int>>& graph) {
        int n = graph.size();
        vector<int> color(n, -1);        
        vector<int> vis(n, 0);
        bool ans = true;
        for (int i = 0; i < n; i++) {
            if (!vis[i]) {
                bool temp = bfs(i, graph, color, vis);
                ans = ans & temp;
            }
        }
        return ans;
    }
};

// DFS
class Solution {
public:
    bool dfs(int node, int parent, vector<vector<int>>& graph, vector<int>& color) {
        if (parent == -1 || color[parent] == 2) {
            color[node] = 1;
        } else {
            color[node] = 2;
        }
        for (auto ngr : graph[node]) {
            if (color[ngr] == -1) {
                if (dfs(ngr, node, graph, color) == false)
                    return false;
            } else if (color[ngr] == color[node])
                return false;
        }
        return true;
    }
    bool isBipartite(vector<vector<int>>& graph) {
        int n = graph.size();
        vector<int> color(n, -1);
        for (int i = 0; i < n; i++) {
            if (color[i] == -1 && dfs(i, -1, graph, color) == false)
                return false;
        }
        return true;
    }
};

// Cycle Detection in Directed Graph (DFS)

#include <bits/stdc++.h>
bool dfs(int node, vector<int> adj[], int vis[], int pathvis[]){
    vis[node] = 1;
    pathvis[node] = 1;
    for (auto it : adj[node]){
        if (!vis[it]){
        if (dfs(it, adj, vis, pathvis) == true)
            return true;
        }
        else if (pathvis[it]){
        return true;
        }
    }
    pathvis[node] = 0;
    return false;
}
bool isCyclic(vector<vector<int>> &edges, int v, int e){
    int n = v;
    vector<int> adj[n];
    for (auto i : edges)
        adj[i[0]].push_back(i[1]);
    int vis[n] = {0};
    int pathvis[n] = {0};
    for (int i = 0; i < n; i++){
        if (!vis[i]){
            if (dfs(i, adj, vis, pathvis) == true)
                return true;
            }
    }
    return false;
}

/* Step 15.3: Topo Sort and Problems */

// Topo Sort		

#include <bits/stdc++.h>
void dfs(int node, vector<int> adj[], int vis[], stack<int>& st){
    vis[node] = 1;
    for(auto it : adj[node]){
        if(!vis[it]){
            dfs(it, adj, vis, st);
        }
    }
    st.push(node);
}
vector<int> topologicalSort(vector<vector<int>> &graph, int edges, int nodes) {
    vector<int> adj[nodes];
    for(auto it : graph){
        adj[it[0]].push_back(it[1]);
    }
    int vis[nodes] = {0};
    stack<int> st;
    for(int i = 0; i < nodes; i++){
        if(!vis[i]){
            dfs(i, adj, vis, st);
        }
    }
    vector<int> ans;
    for(int i = 0; i < nodes; i++){
        ans.push_back(st.top());
        st.pop();
    }
    return ans;
}

// Kahn's Algorithm		

#include <vector>
#include <queue>
vector<int> topologicalSort(vector<vector<int>> &graph, int edges, int nodes) {
    vector<int> indegree(nodes, 0);
    vector<vector<int>> adj(nodes);
    for(auto it : graph){
        adj[it[0]].push_back(it[1]);
        indegree[it[1]]++;
    }
    queue<int> q;
    for(int i = 0; i < nodes; i++){
        if(indegree[i] == 0) 
            q.push(i);
    }
    vector<int> topo;
    while(!q.empty()){
        int node = q.front();
        q.pop();
        topo.push_back(node);
        for(auto it : adj[node]){
            indegree[it]--;
            if(indegree[it] == 0) 
                q.push(it);
        }
    }
    return topo;
}

// Cycle Detection in Directed Graph (BFS)

#include<queue>
bool isCyclic(vector<vector<int>> &edges, int v, int e) {
    vector<int> adj[v];
    for (auto it : edges) {
        int from = it[0];
        int to = it[1];
        adj[from].push_back(to);
    }
    int indegree[v] = {0};
    for (int i = 0; i < v; i++) {
        for (auto it : adj[i])
        indegree[it]++;
    }
    queue<int> q;
    for (int i = 0; i < v; i++) {
        if (indegree[i] == 0)
        q.push(i);
    }
    int cnt = 0;
    while (!q.empty()) {
        int node = q.front();
        q.pop();
        cnt++;
        for (auto it : adj[node]) {
        indegree[it]--;
        if (indegree[it] == 0)
            q.push(it);
        }
    }
    if (cnt == v)
        return false;
    return true;
}

// Course Schedule - I		
	
class Solution {
public:
    bool iscycle(vector<int> adj[], vector<int>& vis, int id) {
        if (vis[id] == 1) {
            return true;
        }
        if (vis[id] == 0) {
            vis[id] = 1; // mark the current node as visited(in process)
            // recursively check for cycles in the adjacent nodes
            for (auto edge : adj[id]) {
                if (iscycle(adj, vis, edge)) {
                    return true;
                }
            }
        }
        vis[id] = 2; // mark the current node as visited(processed)
        return false;
    }
    bool canFinish(int n, vector<vector<int>>& pre) {
        vector<int> adj[n];
        for (auto edge : pre) {
            adj[edge[1]].push_back(edge[0]);
        }
        vector<int> vis(n, 0);
        for (int i = 0; i < n; i++) {
            if (iscycle(adj, vis, i)) {
                return false;
            }
        }
        return true;
    }
};

// Course Schedule - II		
	
class Solution {
public:
    vector<int> findOrder(int numCourses, vector<vector<int>>& pre) {
        // created the adj matrix
        vector<vector<int>> adj_matrix(numCourses, vector<int>(numCourses, 0));
        // bi-->ai
        for (int i = 0; i < pre.size(); i++) {
            adj_matrix[pre[i][1]][pre[i][0]] = 1;
        }
        // we have prepared the adj matrix all we have to do is now find the toplogical sorting of the graph
        // if there exist any
        stack<int> topo_ordering;
        vector<int> indegree(numCourses, 0);
        // find all the nodes indegree or in other words number of dependencies they have
        for (int i = 0; i < numCourses; i++) {
            for (int j = 0; j < numCourses; j++) {
                // i--j means i must be come before j then j has a dependency
                if (adj_matrix[i][j])
                    indegree[j]++;
            }
        }
        // now if there are any nodes with indegree 0 they are free from dependencies they can come in any order
        for (int i = 0; i < numCourses; i++) {
            if (indegree[i] == 0)
                topo_ordering.push(i);
        }
        vector<int> ans;
        // say if there are no such nodes dependency free then there is no ordering
        while (!topo_ordering.empty() ) {
            int temp = topo_ordering.top();
            topo_ordering.pop();
            ans.push_back(temp);
            for (int i = 0; i < numCourses; i++) {
                if (adj_matrix[temp][i]) {
                    indegree[i]--;
                    if (indegree[i] == 0) {
                        topo_ordering.push(i);
                    }
                }
            }
        }
        if (ans.size() != numCourses)
            return {};
        return ans;
    }
};

// Find eventual safe states		
	
// BFS
class Solution {
public:
    vector<int> eventualSafeNodes(vector<vector<int>>& graph) {
        int V = graph.size();
        vector<int> res;
        vector<int> indeg(V, 0);
        vector<vector<int>> adj(V, vector<int>());
        for (int i = 0; i < V; i++) {
            for (auto e : graph[i]) {
                adj[e].push_back(i);
                indeg[i]++;
            }
        }
        queue<int> q;
        for (int i = 0; i < V; i++) {
            if (indeg[i] == 0)
                q.push(i);
        }
        while (!q.empty()) {
            int node = q.front();
            q.pop();
            res.push_back(node);
            for (auto i : adj[node]) {
                indeg[i]--;
                if (indeg[i] == 0)
                    q.push(i);
            }
        }
        sort(res.begin(), res.end());
        return res;
    }
};

// DFS
class Solution {
public:
    bool detectCycle(int v, vector<vector<int>>& graph, vector<int>& vis, vector<int>& pathVis) {
        vis[v] = 1;
        pathVis[v] = 1;
        for (auto& nb : graph[v]) {
            if (vis[nb] == 0) {
                if (detectCycle(nb, graph, vis, pathVis))
                    return true;
            } else {
                if (pathVis[nb] == 1) {
                    return true;
                }
            }
        }
        pathVis[v] = 0;
        return false;
    }
    vector<int> eventualSafeNodes(vector<vector<int>>& graph) {
        int v = graph.size();
        vector<int> ans;
        vector<int> vis(v, 0);
        vector<int> pathVis(v, 0);
        for (int i = 0; i < v; i++) {
            if (!detectCycle(i, graph, vis, pathVis)) {
                ans.push_back(i);
            }
        }
        return ans;
    }
};

// Alien dictionary		
	
class Solution{
public:
    void addEdge(vector<int> adj[], string s, string t) {
        int i = 0, j = 0;
        while (i < s.length() && j < t.length() && s[i] == t[j]) {
            i++;
            j++;
        }
        if (i < s.length() && j < t.length()) {
            adj[s[i] - 'a'].push_back(t[j] - 'a');
        }
    }
    void topologicalSortUtil(int v, vector<int> adj[], vector<bool>& visited, stack<int>& s) {
        visited[v] = true;
        for (int i = 0; i < adj[v].size(); i++) {
            int u = adj[v][i];
            if (!visited[u]) {
                topologicalSortUtil(u, adj, visited, s);
            }
        }
        s.push(v);
    }
    string findOrder(string dict[], int N, int K) {
        vector<int> adj[K];
        for (int i = 0; i < N - 1; i++) {
            addEdge(adj, dict[i], dict[i + 1]);
        }
        vector<bool> visited(K, false);
        stack<int> s;
        for (int i = 0; i < K; i++) {
            if (!visited[i]) {
                topologicalSortUtil(i, adj, visited, s);
            }
        }
        string ans = "";
        while (!s.empty()) {
            ans += (char)(s.top() + 'a');
            s.pop();
        }
        return ans;
    }
};

/* Step 15.4: Shortest Path Algorithms and Problems */

// Shortest Path in UG with unit weights

vector<int> shortestPath(int n, vector<vector<int>> &edges, int src) {
    vector<int> adj[n];
    for (int i = 0; i < edges.size(); i++) {
        int u = edges[i][0];
        int v = edges[i][1];
        adj[u].push_back(v);
        adj[v].push_back(u);
    }
    vector<int> distance(n, -1);
    distance[src] = 0;
    queue<int> q;
    q.push(src);
    while (!q.empty()) {
        int node = q.front();
        q.pop();
        for (auto &child : adj[node]) {
            if (distance[child] == -1) {
                distance[child] = distance[node] + 1;
                q.push(child);
            }
        }
    }
    return distance;
}

// Shortest Path in DAG		

vector<int> shortestPathInDAG(int n, int m, vector<vector<int>> &edges){
    vector<vector<pair<int,int>>> adj(n);
    for(int i=0;i<m;i++){
        int u=edges[i][0];
        int v=edges[i][1];
        int w=edges[i][2];
        adj[u].push_back({v,w});
    }
    queue<pair<int,int>> q;
    vector<int> distance(n,INT_MAX);
    q.push({0,0});
    distance[0]=0;
    while(!q.empty()){
        pair<int,int> front=q.front();
        int node=front.first;
        int dist=front.second;
        q.pop();
        for(auto i:adj[node]){
            if(distance[i.first]>(i.second+dist)){
                distance[i.first]=i.second+dist;
                q.push({i.first,distance[i.first]});
            }
        }
    }
    for(int i=0;i<n;i++){
        if(distance[i]==INT_MAX){
            distance[i]=-1;
        }
    }
    return distance;
}

// Djisktra's Algorithm		

#include<bits/stdc++.h>
vector<int> dijkstra(vector<vector<int>> &vec, int vertices, int edges, int source) {
    unordered_map<int, list<pair<int, int> > > adj;
    for(int i = 0; i < edges; i++){
        int u = vec[i][0];
        int v = vec[i][1];
        int w = vec[i][2];
        adj[u].push_back(make_pair(v,w));
        adj[v].push_back(make_pair(u,w));
    }
    vector<int> dis(vertices);
    for(int i = 0; i < vertices; i++)
        dis[i] = INT_MAX;
    set<pair<int, int> > st;
    st.insert(make_pair(0, source));
    dis[source] = 0;
    while(!st.empty()){
        auto top = *(st.begin());
        int nodeDis = top.first;
        int topnode = top.second;
        st.erase(st.begin());        
        for(auto neighbour : adj[topnode]){
            if(nodeDis + neighbour.second < dis[neighbour.first]){
                auto record = st.find(make_pair(dis[neighbour.first], neighbour.first));
                if(record != st.end())
                    st.erase(record);
                dis[neighbour.first] = nodeDis + neighbour.second;
                st.insert(make_pair(dis[neighbour.first], neighbour.first));
            }
        }
    }
    return dis;
}

// Why priority Queue is used in Djisktra Algorithm		

vector<int> dijkstra(vector<vector<int>> &edge, int vertices, int edges, int source){
    vector<vector<int>> adj[vertices];
    for(auto it : edge){
        int node = it[0];
        int adjNode = it[1];
        int len = it[2];
        adj[node].push_back({adjNode,len});
        adj[adjNode].push_back({node,len});
    }
    priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>>pq;
    vector<int>dist(vertices,1e9);
    dist[source] = 0;
    pq.push({0,source});
    while(!pq.empty()){
        int node = pq.top().second;
        int len = pq.top().first;
        pq.pop();
        for(auto it : adj[node]){
            int adjNode = it[0];
            int adjDis = it[1];
            if(len + adjDis < dist[adjNode]){
                dist[adjNode] = len + adjDis;
                pq.push({dist[adjNode],adjNode});
            }
        }
    }
    return dist;
}

// Shortest path in a binary maze		
	
class Solution {
public:
    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {
        queue<pair<int, pair<int, int>>> q; // Queue to store distance and coordinates
        int n = grid.size();
        int m = grid[0].size();
        // Check if starting cell is blocked
        if (grid[0][0] == 1)
            return -1;
        // Check if destination cell is blocked
        if (grid[n - 1][m - 1] == 1)
            return -1;
        // If there is only one cell and it is reachable
        if (n == 1 && grid[0][0] == 0)
            return 1;
        // Push the starting cell into the queue with distance 1
        q.push({1, {0, 0}});
        // Array to represent movements in row and column directions
        int delRow[] = {-1, 0, 1, 0, 1, -1, -1, 1};
        int delCol[] = {0, 1, 0, -1, 1, 1, -1, -1};
        while (!q.empty()) {
            int dis = q.front().first; // Distance of current cell from the starting cell
            int row = q.front().second.first; // Row index of current cell
            int col = q.front().second.second; // Column index of current cell
            q.pop(); // Remove the current cell from the queue
            // Check all eight neighboring cells
            for (int i = 0; i < 8; i++) { // Loop through neighbors
                int newRow = row + delRow[i]; // Calculate new row index
                int newCol = col + delCol[i]; // Calculate new column index
                // Check if the new cell is within the grid boundaries and is unblocked
                if (newRow >= 0 && newRow < n && newCol >= 0 && newCol < m && grid[newRow][newCol] == 0) {
                    // Mark the cell as visited (-1) to avoid revisiting
                    grid[newRow][newCol] = -1;
                    // If the new cell is the destination, return the distance + 1
                    if (newRow == n - 1 && newCol == m - 1) {
                        return dis + 1;
                    }
                    // Push the new cell into the queue with distance incremented by 1
                    q.push({dis + 1, {newRow, newCol}});
                }
            }
        }
        // If destination cell is unreachable or there is no path, return -1
        return -1;
    }
};

// Path with minimum effort	
	
class Solution {
public:
    int minimumEffortPath(vector<vector<int>>& heights) {
        priority_queue<pair<int, pair<int, int>>, vector<pair<int, pair<int, int>>>, greater<pair<int, pair<int, int>>>> pq;
        int n = heights.size();
        int m = heights[0].size();
        vector<vector<int>> dist(n, vector<int>(m, 1e9));
        dist[0][0] = 0;
        pq.push({0, {0, 0}});
        int delR[] = {-1, 0, 1, 0};
        int delC[] = {0, 1, 0, -1};
        while (!pq.empty()) {
            auto it = pq.top();
            pq.pop();
            int difference = it.first;
            int r = it.second.first;
            int c = it.second.second;
            if (r == n - 1 && c == m - 1)
                return difference;
            for (int i = 0; i < 4; i++) {
                int nr = r + delR[i];
                int nc = c + delC[i];
                if (nr >= 0 && nr < n && nc >= 0 && nc < m) {
                    int newEffort;
                    newEffort = max((abs(heights[r][c] - heights[nr][nc])), difference);
                    if (newEffort < dist[nr][nc]) {
                        dist[nr][nc] = newEffort;
                        pq.push({newEffort, {nr, nc}});
                    }
                }
            }
        }
        return 0;
    }
};

// Cheapest flights within k stops		
	
class Solution {
public:
    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {
        vector<int> distance(n, INT_MAX);
        unordered_map<int, vector<pair<int, int>>> adj;
        for (vector<int>& a : flights) {
            int u = a[0];
            int v = a[1];
            int cost = a[2];
            adj[u].push_back({v, cost});
        }
        queue<pair<int, int>> q;
        q.push({src, 0});
        int steps = 0;
        while (!q.empty() && steps <= k) {
            int size = q.size();
            while (size--) {
                int u = q.front().first;
                int d = q.front().second;
                q.pop();
                for (pair<int, int>& p : adj[u]) {
                    int v = p.first;
                    int cost = p.second;
                    if (distance[v] > d + cost) {
                        distance[v] = d + cost;
                        q.push({v, d + cost});
                    }
                }
            }
            steps++;
        }
        return distance[dst] == INT_MAX ? -1 : distance[dst];
    }
};

// Network Delay time				

class Solution {
public:
    int networkDelayTime(vector<vector<int>>& times, int n, int k) {
        vector<pair<int, int>> adj[n + 1];
        for (auto it : times) {
            int u = it[0];  // source node
            int v = it[1];  // destination node
            int wt = it[2]; // weight or time taken to travel from u to v
            adj[u].push_back({v, wt});
        }
        // Create a priority queue for Dijkstra's algorithm
        // Pair (time, node) is used where 'time' represents time taken to reach
        // 'node' and 'node' represents the node number
        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;
        // Push the source node 'k' with time 0 to the priority queue
        pq.push({0, k});
        // Initialize an array to keep track of minimum distances from the source node 'k' to all other nodes
        vector<int> dist(n + 1, INT_MAX);
        dist[k] = 0; // Distance from 'k' to itself is 0
        while (!pq.empty()) {
            int time = pq.top().first;  // Time taken to reach the current node
            int node = pq.top().second; // Current node
            pq.pop();
            // Iterate over all adjacent nodes of the current node
            for (auto it : adj[node]) {
                int neighbourNode = it.first; // Neighbouring node
                int wt = it.second; // Weight of the edge between 'node' and 'neighbourNode'
                // If the total time taken to reach 'neighbourNode' through
                // 'node' is less than the current recorded distance to
                // 'neighbourNode', update the distance
                if (time + wt < dist[neighbourNode]) {
                    dist[neighbourNode] = time + wt;
                    // Push the updated distance and the neighbouring node to the priority queue
                    pq.push({dist[neighbourNode], neighbourNode});
                }
            }
        }
        // Find the maximum distance in 'dist' array
        int mx = *max_element(dist.begin() + 1, dist.end());
        // If mx is still INT_MAX, it means some nodes are not reachable from
        // the source 'k', so return -1, otherwise return the maximum distance
        return mx == INT_MAX ? -1 : mx;
    }
};

// Number of ways to arrive at destination		
	
#define ll long long
class Solution {
public:
    int M = 1e9 + 7;
    int countPaths(int n, vector<vector<int>>& roads) {
        ll src = 0;
        // create an adjancy list
        vector<pair<ll, ll>> adj[n];
        for (auto it : roads) {
            int u = it[0];
            int v = it[1];
            int wt = it[2];
            adj[u].push_back({v, wt});
            adj[v].push_back({u, wt});
        }
        // time is very --> so we use the  priority queue..
        priority_queue<pair<ll, ll>, vector<pair<ll, ll>>, greater<pair<ll, ll>>> pq;
        // push the things--> {dis ,node}
        pq.push({0, 0});
        // make the distance vector
        vector<ll> dist(n, LLONG_MAX);
        dist[src] = 0;
        // make the ways vector
        vector<ll> ways(n, 0);
        ways[src] = 1;
        while (!pq.empty()) {
            ll dis = pq.top().first;
            ll curr_node = pq.top().second;
            pq.pop();
            for (auto it : adj[curr_node]) {
                ll neighnode = it.first;
                ll wt = it.second;
                if (dis + wt < dist[neighnode]) {
                    dist[neighnode] = dis + wt;
                    pq.push({dist[neighnode], neighnode});
                    ways[neighnode] = ways[curr_node];
                }
                else if (dis + wt == dist[neighnode]) {
                    ways[neighnode] = (ways[neighnode] + ways[curr_node]) % M;
                }
            }
        }
        return ways[n - 1] % M;
    }
};

// Minimum multiplications to reach end		

int minimumOperations(int n, int start, int end, vector<int> &a){
    vector<bool> visited(1000,false);
    queue<pair<int,int>> q;
    q.push({0,start});
    visited[start] = true;
    while(!q.empty()){
        int node = q.front().second;
        int dist = q.front().first;
        q.pop();
        if(node == end){
            return dist;
        }
        for(auto i: a){
            int val = (i*node)%1000;
            if(visited[val]==false){
              visited[val] = true;
              q.push({dist+1,val});
            }
        }
    }
    return -1;
}

// Bellman Ford Algorithm		

#include <bits/stdc++.h> 
int bellmonFord(int n, int m, int src, int dest, vector<vector<int>> &edges) {
    vector<int> dist(n+1, 1e9);
    dist[src] = 0;
    for (int i=1; i<=n; i++){
        for (int j=0; j<m; j++){
            int u = edges[j][0];
            int v = edges[j][1];
            int wt = edges[j][2];
            if (dist[u] != 1e9 && ((dist[u]+wt) < dist[v])){
                dist[v] = dist[u]+wt;
            }
        }
    }
    return dist[dest];

    // if -ve cycle is present
    // bool flag = 0;
    // for (int j=0; j<m; j++){
    //     int u = edges[j][0];
    //     int v = edges[j][1];
    //     int wt = edges[j][2];
    //     if (dist[u] != 1e9 && ((dist[u]+wt) < dist[v])){
    //         bool flag = 1;
    //     }
    // }
    // if (flag == 0){
    //     return dist[dest];
    // }
    // return -1;
}


// Floyd Warshal Algorithm		

int floydWarshall(int n, int m, int src, int dest, vector<vector<int>> &edges) {
    vector<vector<int>> matrix(n + 1, vector<int>(n + 1, 1e9));
    for (auto i : edges) {
        matrix[i[0]][i[1]] = i[2];
    }
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= n; j++) {
            if (i == j)
                matrix[i][j] = 0;
        }
    }
    for (int k = 1; k <= n; k++) {
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= n; j++) {
                if (matrix[i][k] != 1e9 && matrix[k][j] != 1e9)
                    matrix[i][j] = min(matrix[i][j], matrix[i][k] + matrix[k][j]);
            }
        }
    }
    return matrix[src][dest];
}

// Find the city with the smallest number of neighbours in a threshold distance		

class Solution {
public:
    int findTheCity(int n, vector<vector<int>>& edges, int distanceThreshold) {
        // Initialising distance array
        vector<vector<int>> dist(n, vector<int>(n, 1e9));
        for (int i = 0; i < n; i++) {
            dist[i][i] = 0;
        }
        // Marking its weight from one city to its neighbour city
        for (auto it : edges) {
            int from = it[0];
            int to = it[1];
            int weight = it[2];
            dist[from][to] = weight;
            dist[to][from] = weight;
        }
        // Implementing Floyd Warshall Algorithm
        for (int thr = 0; thr < n; thr++) {
            for (int i = 0; i < n; i++) {
                for (int j = 0; j < n; j++) {
                    if (dist[i][j] > dist[i][thr] + dist[thr][j]) {
                        dist[i][j] = dist[i][thr] + dist[thr][j];
                    }
                }
            }
        }
        int mincnt = n, city = -1;
        // Finding the no of cities can be reached from each city in the threshold distance
        for (int i = 0; i < n; i++) {
            int cnt = 0;
            for (int j = 0; j < n; j++) {
                if (dist[i][j] <= distanceThreshold) {
                    cnt++;
                }
            }
            if (mincnt >= cnt) {
                mincnt = cnt;
                city = i;
            }
        }
        return city;
    }
};

/* Step 15.5: MinimumSpanningTree/Disjoint Set and Problems */

// Minimum Spanning Tree		

A spanning tree is a tree in which we have N nodes(i.e. All the nodes present in the original graph) and N-1 edges and all nodes are reachable from each other.
Among all possible spanning trees of a graph, the minimum spanning tree is the one for which the sum of all the edge weights is the minimum.

// Prim's Algorithm		

class Solution{
public:
    int spanningTree(int V, vector<vector<int>> adj[]){
        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;
        pq.push({0, 0});
        vector<int> vis(V, 0);
        int sum = 0;
        while(!pq.empty()){
            int wt = pq.top().first;
            int node = pq.top().second;
            pq.pop();
            if(vis[node] == 1){
                continue;
            }
            vis[node] = 1;
            sum += wt;
            for(auto i : adj[node]){
                int adjNode = i[0];
                int adjWt = i[1];
                if(!vis[adjNode]){
                    pq.push({adjWt, adjNode});
                }
            }
        }
        return sum;
    }
};

// Disjoint Set [Union by Rank]		

int find(int parent[],int X){
	if(parent[X] == X){
        	return X;
        }
	else{
          int result = find(parent,parent[X]);
          parent[X] = result;
          return result;
        } 
}
void unionSet(int parent[],int X,int Z){
        int x_parent = find(parent,X);
        int z_parent = find(parent,Z);
        if(x_parent == z_parent){
        	return;
        }
	else{
             parent[x_parent] = z_parent;
        }
}

// Disjoint Set [Union by Size]		

#include <bits/stdc++.h>
using namespace std;
class DisjointSet {
    vector<int> rank, parent, size;
public:
    DisjointSet(int n) {
        rank.resize(n + 1, 0);
        parent.resize(n + 1);
        size.resize(n + 1);
        for (int i = 0; i <= n; i++) {
            parent[i] = i;
            size[i] = 1;
        }
    }

    int findUPar(int node) {
        if (node == parent[node])
            return node;
        return parent[node] = findUPar(parent[node]);
    }

    void unionByRank(int u, int v) {
        int ulp_u = findUPar(u);
        int ulp_v = findUPar(v);
        if (ulp_u == ulp_v) return;
        if (rank[ulp_u] < rank[ulp_v]) {
            parent[ulp_u] = ulp_v;
        }
        else if (rank[ulp_v] < rank[ulp_u]) {
            parent[ulp_v] = ulp_u;
        }
        else {
            parent[ulp_v] = ulp_u;
            rank[ulp_u]++;
        }
    }

    void unionBySize(int u, int v) {
        int ulp_u = findUPar(u);
        int ulp_v = findUPar(v);
        if (ulp_u == ulp_v) return;
        if (size[ulp_u] < size[ulp_v]) {
            parent[ulp_u] = ulp_v;
            size[ulp_v] += size[ulp_u];
        }
        else {
            parent[ulp_v] = ulp_u;
            size[ulp_u] += size[ulp_v];
        }
    }
};
int main() {
    DisjointSet ds(7);
    ds.unionBySize(1, 2);
    ds.unionBySize(2, 3);
    ds.unionBySize(4, 5);
    ds.unionBySize(6, 7);
    ds.unionBySize(5, 6);
    // if 3 and 7 same or not
    if (ds.findUPar(3) == ds.findUPar(7)) {
        cout << "Same\n";
    }
    else cout << "Not same\n";

    ds.unionBySize(3, 7);

    if (ds.findUPar(3) == ds.findUPar(7)) {
        cout << "Same\n";
    }
    else cout << "Not same\n";
    return 0;
}

// Kruskal's Algorithm		

class Solution{
public:
    class DisjointSet{
        vector<int> parent, size;
        public:
        DisjointSet(int n){
            parent.resize(n+1);
            for(int i=0; i<n+1; i++)
                parent[i] = i;
            size.resize(n+1, 1);
        }
        int findparent(int node){  
            if(node == parent[node])
                return node;
            // Path compression
            return parent[node] = findparent(parent[node]);
        }
        void Union(int u, int v){
            int ulp_u = findparent(u);
            int ulp_v = findparent(v);
            if(ulp_u == ulp_v)
                return;
            else if(size[ulp_u] > size[ulp_v]){
                parent[ulp_v] = ulp_u;
                size[ulp_v] += size[ulp_u];
            }
            else{
                parent[ulp_u] = ulp_v;
                size[ulp_u] += size[ulp_v];
            }
        }
    };
    int spanningTree(int V, vector<vector<int>> adj[]){
        int cost = 0;
        // Step 1: Create a datastructure to store {w, u, v}
        vector<pair<int, pair<int, int>>> edges;
        for(int u=0; u<V; u++){
            for(int j=0; j<adj[u].size(); j++){
                int v = adj[u][j][0];
                int w = adj[u][j][1];
                edges.push_back({w, {u, v}});
            }
        }
        // Step 2: Sort the datastructure
        sort(edges.begin(), edges.end());
        // Step 3: take one by one edge from datastructure and form spanning tree
        DisjointSet ds(V);
        for(int i=0; i<edges.size(); i++){
            int u = edges[i].second.first;
            int v = edges[i].second.second;
            int w = edges[i].first;
            if(ds.findparent(u) != ds.findparent(v)){
                cost += w;
                ds.Union(u, v);
            }
        }
        return cost;
    }
};

// Number of operations to make network connected		
	
// Method-1
class Solution {
public:
    void dfs(vector<vector<int>>&adj, vector<bool>&visited, int currNode)
    { 
        visited[currNode] = true;
        for (int adjNode : adj[currNode])
        {
            if (visited[adjNode]) continue;
            dfs(adj, visited, adjNode);
        }
    }
    int makeConnected(int n, vector<vector<int>>& connections) 
    {
        int currWireCount = connections.size();
        int requiredWireCount = n - 1;
        if (currWireCount < requiredWireCount) return -1;
        vector<vector<int>>adj(n);
        for (vector<int>connection : connections)
        {
            adj[connection[0]].push_back(connection[1]);
            adj[connection[1]].push_back(connection[0]);
        }
        vector<bool>visited(n, false);
        int componentCount = 0;
        for (int node = 0; node < n; node++)
        {
            if (visited[node]) continue;
            dfs(adj, visited, node);
            componentCount++;
        }
        return componentCount - 1;
    }
};

// Method-2
class Solution {
public:
    // Find the parent of a node using path compression.
    int find(vector<int>& parent, int i) {
        if (parent[i] != i) {
            parent[i] = find(parent, parent[i]);
        }
        return parent[i];
    }
    int makeConnected(int n, vector<vector<int>>& connections) {
        // If the number of connections is less than n - 1, 
        // it's impossible to connect all computers.
        if (connections.size() < n - 1) {
            return -1;
        }
        // Initialize parent array to keep track of the parent of each node.
        vector<int> parent(n);
        for (int i = 0; i < n; i++) {
            parent[i] = i;
        }
        // Initialize the count of unconnected nodes to n.
        int count = n;
        // Iterate over the connections and connect the nodes using union-find algorithm.
        for (int i = 0; i < connections.size(); i++) {
            int u = connections[i][0], v = connections[i][1];
            int pu = find(parent, u), pv = find(parent, v);
            if (pu != pv) {
                parent[pu] = pv;
                count--;
            }
        }
        // Return the number of times we need to extract and place a cable to connect all computers.
        return count - 1;
    }
};

// Most stones removed with same rows or columns

// Method-1
class Solution {
public:
    bool isValid(vector<int>& pos1, vector<int>& pos2) {
        if (pos1[0] == pos2[0])
            return true;
        if (pos1[1] == pos2[1])
            return true;
        return false;
    }
    int findParent(vector<int>& parent, int node) {
        while (parent[node] != node) {
            node = parent[node];
        }
        return node;
    }
    void merge(vector<int>& parent, int& componentCount, int node1, int node2) {
        int parent1 = findParent(parent, node1);
        int parent2 = findParent(parent, node2);
        if (parent1 != parent2) {
            componentCount--;
            parent[parent1] = parent2;
        }
    }
    int removeStones(vector<vector<int>>& stones) {
        int n = stones.size();
        vector<int> parent(n);
        for (int i = 0; i < n; i++)
            parent[i] = i;
        int componentCount = n;
        for (int i = 0; i < n; i++) {
            for (int j = i; j < n; j++) {
                if (isValid(stones[i], stones[j]))
                    merge(parent, componentCount, i, j);
            }
        }
        return (n - componentCount);
    }
};

// Method-2
class Solution {
public:
    bool isValid(vector<int>& pos1, vector<int>& pos2) {
        if (pos1[0] == pos2[0])
            return true;
        if (pos1[1] == pos2[1])
            return true;
        return false;
    }
    void dfs(vector<vector<int>>& stones, vector<bool>& visited, int currIdx) {
        visited[currIdx] = true;
        for (int i = 0; i < stones.size(); i++) {
            if (visited[i])
                continue;
            if (isValid(stones[i], stones[currIdx]))
                dfs(stones, visited, i);
        }
    }
    int removeStones(vector<vector<int>>& stones) {
        int n = stones.size();
        vector<bool> visited(n, false);
        int componentCount = 0;
        for (int i = 0; i < n; i++) {
            if (visited[i])
                continue;
            dfs(stones, visited, i);
            componentCount++;
        }
        return (n - componentCount);
    }
};

// Accounts merge		
	
class DisjointSet {
    vector<int> rank, parent, size;
public:
    DisjointSet(int n) {
        rank.resize(n + 1, 0);   // Initialize rank array with 0
        parent.resize(n + 1, 0); // Initialize parent array with 0
        size.resize(n + 1, 0);   // Initialize size array with 0
        for (int i = 0; i < n; i++) {
            parent[i] = i; // Each node is its own parent initially
            size[i] = 1;   // Initial size of each component is 1
        }
    }

    int findUPar(int node) {
        // Find the ultimate parent of the node with path compression
        if (node == parent[node])
            return node;
        return parent[node] = findUPar(parent[node]);
    }

    void unionByRank(int u, int v) {
        // Union by rank logic
        int ulp_u = findUPar(u);
        int ulp_v = findUPar(v);
        if (ulp_u == ulp_v)
            return; // If they have the same ultimate parent, no union is needed

        // Union by comparing ranks
        if (rank[ulp_u] < rank[ulp_v]) {
            parent[ulp_u] = ulp_v;
        } else if (rank[ulp_v] < rank[ulp_u]) {
            parent[ulp_v] = ulp_u;
        } else {
            parent[ulp_v] = ulp_u;
            rank[ulp_u]++;
        }
    }

    void unionBySize(int u, int v) {
        // Union by size logic
        int ulp_u = findUPar(u);
        int ulp_v = findUPar(v);
        if (ulp_u == ulp_v)
            return; // If they have the same ultimate parent, no union is needed

        // Union by comparing sizes
        if (size[ulp_u] < size[ulp_v]) {
            parent[ulp_u] = ulp_v;
            size[ulp_v] += size[ulp_u];
        } else {
            parent[ulp_v] = ulp_u;
            size[ulp_u] += size[ulp_v];
        }
    }
};

class Solution {
public:
    vector<vector<string>> accountsMerge(vector<vector<string>>& details) {
        int n = details.size();
        DisjointSet ds(n);
        sort(details.begin(), details.end());

        // Step 1: Map each email to the corresponding account index
        unordered_map<string, int> mp;
        for (int i = 0; i < n; i++) {
            for (int j = 1; j < details[i].size(); j++) {
                string mail = details[i][j];
                if (mp.find(mail) == mp.end()) {
                    // If the email is not yet in the map, add it with the
                    // current index
                    mp[mail] = i;
                } else {
                    // If the email is already in the map, union the current
                    // index with the stored index
                    ds.unionBySize(i, mp[mail]);
                }
            }
        }

        // Step 2: Aggregate emails under the ultimate parent
        vector<string> mergelist[n];
        for (auto it : mp) {
            int idx = it.second;
            string mail = it.first;
            int ult_parent = ds.findUPar(idx);
            mergelist[ult_parent].push_back(mail);
        }

        // Step 3: Form the result
        vector<vector<string>> ans;
        for (int i = 0; i < n; i++) {
            if (mergelist[i].empty())
                continue;
            sort(mergelist[i].begin(), mergelist[i].end());
            vector<string> tmp;
            tmp.push_back(details[i][0]); // Add the account name
            for (int j = 0; j < mergelist[i].size(); j++) {
                tmp.push_back(mergelist[i][j]); // Add the emails
            }
            ans.push_back(tmp);
        }
        sort(ans.begin(), ans.end());
        return ans;
    }
};

// Number of island

class Solution {
public:
    void solve(vector<vector<char>> &grid, int i, int j, int m, int n) {
        if (i < 0 || i >= m || j < 0 || j >= n || grid[i][j] != '1') {
            return;
        }
        grid[i][j] = 'x';
        solve(grid, i + 1, j, m, n);
        solve(grid, i - 1, j, m, n);
        solve(grid, i, j + 1, m, n);
        solve(grid, i, j - 1, m, n);
    }
    int numIslands(vector<vector<char>>& grid) {
        int m = grid.size(), n = grid[0].size();
        int count = 0;
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (grid[i][j] == '1') {
                    solve(grid, i, j, m, n);
                    count++;
                }
            }
        }
        return count;
    }
};

// Number of island II

class DisjointSet {
    vector<int> rank, parent, size;
public:
    DisjointSet(int n) {
        rank.resize(n + 1, 0);
        parent.resize(n + 1);
        size.resize(n + 1);
        for (int i = 0; i <= n; i++) {
            parent[i] = i;
            size[i] = 1;
        }
    }

    int findUPar(int node) {
        if (node == parent[node])
            return node;
        return parent[node] = findUPar(parent[node]);
    }

    void unionByRank(int u, int v) {
        int ulp_u = findUPar(u);
        int ulp_v = findUPar(v);
        if (ulp_u == ulp_v) return;
        if (rank[ulp_u] < rank[ulp_v]) {
            parent[ulp_u] = ulp_v;
        }
        else if (rank[ulp_v] < rank[ulp_u]) {
            parent[ulp_v] = ulp_u;
        }
        else {
            parent[ulp_v] = ulp_u;
            rank[ulp_u]++;
        }
    }

    void unionBySize(int u, int v) {
        int ulp_u = findUPar(u);
        int ulp_v = findUPar(v);
        if (ulp_u == ulp_v) return;
        if (size[ulp_u] < size[ulp_v]) {
            parent[ulp_u] = ulp_v;
            size[ulp_v] += size[ulp_u];
        }
        else {
            parent[ulp_v] = ulp_u;
            size[ulp_u] += size[ulp_v];
        }
    }
};

class Solution {
private:
    bool isValid(int adjr, int adjc, int n, int m) {
        return adjr >= 0 && adjr < n && adjc >= 0 && adjc < m;
    }
public:
    vector<int> numOfIslands(int n, int m, vector<vector<int>> &operators) {
        DisjointSet ds(n * m);
        int vis[n][m];
        memset(vis, 0, sizeof vis);
        int cnt = 0;
        vector<int> ans;
        for (auto it : operators) {
            int row = it[0];
            int col = it[1];
            if (vis[row][col] == 1) {
                ans.push_back(cnt);
                continue;
            }
            vis[row][col] = 1;
            cnt++;
            // row - 1, col
            // row , col + 1
            // row + 1, col
            // row, col - 1;
            int dr[] = { -1, 0, 1, 0};
            int dc[] = {0, 1, 0, -1};
            for (int ind = 0; ind < 4; ind++) {
                int adjr = row + dr[ind];
                int adjc = col + dc[ind];
                if (isValid(adjr, adjc, n, m)) {
                    if (vis[adjr][adjc] == 1) {
                        int nodeNo = row * m + col;
                        int adjNodeNo = adjr * m + adjc;
                        if (ds.findUPar(nodeNo) != ds.findUPar(adjNodeNo)) {
                            cnt--;
                            ds.unionBySize(nodeNo, adjNodeNo);
                        }
                    }
                }
            }
            ans.push_back(cnt);
        }
        return ans;
    }
};

// Making a Large Island		
	
class DisjointSet {
public:
    vector<int> rank, parent, size;
    DisjointSet(int n) {
        rank.resize(n + 1, 0);
        parent.resize(n + 1);
        size.resize(n + 1);
        for (int i = 0; i <= n; i++) {
            parent[i] = i;
            size[i] = 1;
        }
    }
    int findUPar(int node) {
        if (node == parent[node])
            return node;
        return parent[node] = findUPar(parent[node]);
    }
    void unionBySize(int u, int v) {
        int ulp_u = findUPar(u);
        int ulp_v = findUPar(v);
        if (ulp_u == ulp_v)
            return;
        if (size[ulp_u] < size[ulp_v]) {
            parent[ulp_u] = ulp_v;
            size[ulp_v] += size[ulp_u];
        } else {
            parent[ulp_v] = ulp_u;
            size[ulp_u] += size[ulp_v];
        }
    }
};
class Solution {
public:
    int largestIsland(vector<vector<int>>& grid) {
        int n = grid.size();
        DisjointSet ds(n * n);
        vector<int> dr = {-1, 0, 1, 0};
        vector<int> dc = {0, 1, 0, -1};
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                if (grid[i][j] == 1) {
                    for (int k = 0; k < 4; k++) {
                        int nr = i + dr[k];
                        int nc = j + dc[k];
                        if (nr >= 0 && nr < n && nc >= 0 && nc < n &&
                            grid[nr][nc] == 1) {
                            int nodeno = n * i + j;
                            int adjno = n * nr + nc;
                            ds.unionBySize(adjno, nodeno);
                        }
                    }
                }
            }
        }
        int ans = 1;
        for (int i = 0; i < n * n; i++) {
            ans = max(ans, ds.size[i]);
        }
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                if (grid[i][j] == 0) {
                    unordered_set<int> st;
                    for (int k = 0; k < 4; k++) {
                        int nr = i + dr[k];
                        int nc = j + dc[k];
                        if (nr >= 0 && nr < n && nc >= 0 && nc < n &&
                            grid[nr][nc] == 1) {
                            int adjno = n * nr + nc;
                            st.insert(ds.findUPar(adjno));
                        }
                    }
                    int temps = 1;
                    for (auto it : st) {
                        temps += ds.size[it];
                    }
                    ans = max(ans, temps);
                }
            }
        }
        return ans;
    }
};

// Swim in rising water				

// Method-1
class Solution {
public:
    int swimInWater(vector<vector<int>>& grid) {
        priority_queue<vector<int>, vector<vector<int>>, greater<vector<int>>> pq;
        vector<vector<int>> directions = {{0,1}, {0,-1}, {1,0}, {-1,0}};
        int n = grid.size();
        vector<vector<bool>> visited(n, vector<bool>(n, false));
        pq.push({grid[0][0], 0, 0}); // Push the starting cell with its elevation
        while (!pq.empty()) {
            vector<int> poll = pq.top();
            pq.pop();
            int elevation = poll[0], x = poll[1], y = poll[2];
            if (visited[x][y])
                continue;
            if (x == n-1 && y == n-1)
                return elevation;
            visited[x][y] = true;
            for (auto dir : directions) {
                int X = x + dir[0], Y = y + dir[1];
                if (X >= 0 && Y >= 0 && X < n && Y < n && !visited[X][Y])
                    pq.push({max(elevation, grid[X][Y]), X, Y});
            }
        }
        return 0;
    }
};

// Method-2
class Solution {
    int n;
    bool canReach(int row, int col, vector<vector<int>>& grid, int dr[], int dc[], int depth, vector<vector<bool>>& visited) {
        if (row == n - 1 && col == n - 1)
            return true;
        visited[row][col] = 1;
        for (int i = 0; i < 4; i++) {
            int nr = row + dr[i];
            int nc = col + dc[i];
            if (nr >= 0 && nr < n && nc >= 0 && nc < n && !visited[nr][nc] &&
                grid[nr][nc] <= depth) {
                if (canReach(nr, nc, grid, dr, dc, depth, visited)) {
                    return true;
                }
            }
        }
        return false;
    }
public:
    int swimInWater(vector<vector<int>>& grid) {
        int low = 0, high = 0;
        n = grid.size();
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                high = max(high, grid[i][j]);
            }
        }
        int dr[4] = {-1, 1, 0, 0};
        int dc[4] = {0, 0, -1, 1};
        int res = 0;
        while (low <= high) {
            int mid = low + (high - low) / 2;
            vector<vector<bool>> visited(n, vector<bool>(n, 0));
            if (grid[0][0] <= mid &&
                canReach(0, 0, grid, dr, dc, mid, visited)) {
                res = mid;
                high = mid - 1;
            } else {
                low = mid + 1;
            }
        }
        return res;
    }
};

/* Step 15.6: Other Algorithms */

// Bridges in Graph		
	
class Solution {
public:
    void find_criticalConn(int& timer, int src, int perent, unordered_map<int, list<int>>& adjList,
                           unordered_map<int, bool>& visited, vector<vector<int>>& ans, vector<int>& tin,
                           vector<int>& low) {
        visited[src] = true;
        timer++;
        low[src] = timer;
        tin[src] = timer;
        for (auto nbr : adjList[src]) {
            if (nbr == perent)
                continue;
            if (!visited[nbr]) {
                find_criticalConn(timer, nbr, src, adjList, visited, ans, tin, low);
                low[src] = min(low[src], low[nbr]);
                if (low[nbr] > tin[src]) {
                    ans.push_back({nbr, src});
                }
            } else
                low[src] = min(low[src], low[nbr]);
        }
    }
    vector<vector<int>> criticalConnections(int n, vector<vector<int>>& connections) {
        int timer = 1;
        vector<int> tin(n);
        vector<int> low(n);
        vector<vector<int>> ans;
        unordered_map<int, bool> visited;
        unordered_map<int, list<int>> adjList;
        for (int i = 0; i < connections.size(); i++) {
            int u = connections[i][0];
            int v = connections[i][1];
            adjList[u].push_back(v);
            adjList[v].push_back(u);
        }
        find_criticalConn(timer, 0, -1, adjList, visited, ans, tin, low);
        return ans;
    }
};

// Articulation Point		

class Solution {
public:
    void dfs(int node,int &parent,vector<int> &disc,vector<int> &low,vector<int> adj[],unordered_map<int,bool> &vis,vector<int> &ap,int &timer){
        vis[node]=true;
        disc[node]=low[node]=timer++;
        int child=0;
        // processing the neighbours    
        for(auto neighbour:adj[node]){
            if(neighbour==parent){
                continue;
            }
            if(!vis[neighbour]){
                dfs(neighbour,node,disc,low,adj,vis,ap,timer);
                low[node]=min(low[node],low[neighbour]);
                // to check if articulation point
                if(low[neighbour]>=disc[node] && parent!=-1){
                   ap[node]=1;
                }
                child++;
            }
            else{
                low[node]=min(low[node],disc[neighbour]);
            }
        }
        if(parent == -1 && child > 1){
            ap[node] = 1;
        }
    }
    vector<int> articulationPoints(int V, vector<int>adj[]) {
        vector<int> disc(V,-1);
        vector<int> low(V,-1);
        int parent = -1;
        unordered_map<int,bool> vis;
        vector<int> ap(V,0);
        int timer = 0;
        for(int i = 0; i < V; i++){
            if(!vis[i]){
                dfs(i, parent, disc, low, adj, vis, ap, timer);
            }
        }
        vector<int> ans;
        for(int i = 0; i < V; i++){
            if(ap[i] == 1){
                ans.push_back(i);
            }
        }
        if(ans.size() == 0){
            return {-1};
        }
        sort(ans.begin(), ans.end());
        return ans;
    }
};

// Kosaraju's Algorithm		

class Solution
{
	public:
	//Function to find number of strongly connected components in the graph.
	void dfs(int node,vector<int> &vis,vector<vector<int>>& adj,stack<int> &st){
	    vis[node]=1;
	    for(auto it:adj[node]){
	        if(!vis[it])dfs(it,vis,adj,st);
	    }
	    st.push(node);
	}
	void dfs2(int node,vector<int> &vis,vector<int> adj[]){
	    vis[node]=1;
	    for(auto it:adj[node]){
	        if(!vis[it])dfs2(it,vis,adj);
	    }
	}
    int kosaraju(int V, vector<vector<int>>& adj)
    {
        vector<int> vis(V,0);
        stack<int> st;
        for(int i=0;i<V;i++){
            if(!vis[i]){
                dfs(i,vis,adj,st);
            }
        }
        vector<int> adjT[V];
        for(int i=0;i<V;i++){
            vis[i]=0;
            for(auto it:adj[i]){
                adjT[it].push_back(i);
            }
        }
        int scc=0;
        while(!st.empty()){
            int node=st.top();
            st.pop();
            if(!vis[node]){
                dfs2(node,vis,adjT);
                scc++;
            }
        }
        return scc;
        
    }
};
