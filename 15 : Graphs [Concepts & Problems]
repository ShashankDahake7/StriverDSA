/* Step 15.1: Learning */

// Graph and Types		

vector < vector < int >> printAdjacency(int n, int m, vector < vector < int >> & edges) {
    vector<vector<int>> adj(n);
    for(int j = 0; j < n; j++){
        adj[j].push_back(j);
    }
    for(int i = 0; i < m; i++){
        int u = edges[i][0];
        int v = edges[i][1];
        adj[u].push_back(v);
        adj[v].push_back(u);
    }
    return adj;
}

// Graph Representation | C++		

#include <iostream>
using namespace std;
int main(){
    int n, m;
    cin >> n >> m;
    vector<int> adj[n+1];
    for(int i = 0; i < m; i++){
        int u, v;
        // u â€”> v
        cin >> u >> v;
        adj[u].push_back(v);
    }
    return 0;
}

// Counting Graphs

int countingGraphs(int N){
    return pow(2, N * (N - 1) / 2);
}

// Connected Components | Logic Explanation
	
// Method-(DFS-BFS)
class Solution {
  public:
     void bfs(vector<int> adj[],int vis[],int start){
        queue<int> q;
        q.push(start);
        vis[start]=1;
        while(!q.empty()){
            int node=q.front();
            q.pop();
            for(int it:adj[node]){
                if(!vis[it]){
                    vis[it]=1;
                    q.push(it);
                }
            }
        }
    }
    void dfs(vector<int> adj[],int vis[],int start){
        vis[start]=1;
        for(auto it:adj[start]){
            if(!vis[it]){
                dfs(adj,vis,it);
            }
        }
    }
    int numProvinces(vector<vector<int>> adj, int V) {
        vector<int> adj[V];
        for(int i=0;i<V;i++){
            for(int j=0;j<V;j++){
                if(adj[i][j]==1 && i!=j){
                    adj[i].push_back(j);
                    adj[j].push_back(i);
                }
            }
        }
        int vis[V+1];
        for(int i=0;i<V;i++){
            vis[i] = 0;
        }
        int ans=0;
        for(int i=0;i<V;i++){
            if(vis[i]==0){
                ans++;        
                // bfs(adj,vis,i);
                dfs(adj,vis,i);
            }
        }
        return ans;
    }
};

// BFS		
	
class Solution {
  public:
    vector<int> bfsOfGraph(int V, vector<int> adj[]) {
        vector<int> ans;
        vector<int> vis(V, 0);
        queue<int> q;
        q.push(0);
        vis[0] = 1;
        while(!q.empty()){
            int f = q.front();
            q.pop();
            ans.push_back(f);
            for(auto &it : adj[f]){
                if(!vis[it]){
                    q.push(it);
                    vis[it]=1;
                }
            }
        }
        return ans;
    }
};

// DFS		

class Solution {
  public:
    // Function to return a list containing the DFS traversal of the graph.
    void dfs(int i, vector<int>& vis, vector<int>& ans, vector<int> adj[]){
        vis[i] = 1;
        ans.push_back(i);
        for(auto &it: adj[i]){
            if(!vis[it]){
                dfs(it, vis, ans, adj);
            }
        }
    }
    vector<int> dfsOfGraph(int V, vector<int> adj[]) {
        vector<int> ans;
        vector<int> vis(V, 0);
        dfs(0, vis, ans, adj);
        return ans;
    }
};

/* Step 15.2: Problems on BFS/DFS */

// Number of provinces

// Method-1
class Solution {
public:
    void dfs(vector<int>& vis, vector<vector<int>> adj, int i) {
        vis[i] = 1;
        for (auto i : adj[i]) {
            if (vis[i] == 0) {
                vis[i] = 1;
                dfs(vis, adj, i);
            }
        }
    }
    int findCircleNum(vector<vector<int>>& num) {
        int n = num.size();
        vector<vector<int>> adj(n);
        for (int i = 0; i < num.size(); i++) {
            for (int j = 0; j < num[i].size(); j++) {
                if (i != j && num[i][j] == 1) {
                    adj[i].push_back(j);
                }
            }
        }
        vector<int> vis(n, 0);
        int count = 0;
        for (int i = 0; i < n; i++) {
            if (!vis[i]) {
                dfs(vis, adj, i);
                count++;
            }
        }
        return count;
    }
};

// Method-2
class Solution {
public:
    void bfs(vector<int>& vis, vector<vector<int>> adj, int i) {
        queue<int> q;
        q.push(i);
        vis[i] = 1;
        while(!q.empty()){
            int f = q.front();
            q.pop();
            for(auto x : adj[f]){
                if(!vis[x]){
                    vis[x] = 1;
                    q.push(x);
                }
            }
        }
    }
    int findCircleNum(vector<vector<int>>& num) {
        int n = num.size();
        vector<vector<int>> adj(n);
        for (int i = 0; i < num.size(); i++) {
            for (int j = 0; j < num[i].size(); j++) {
                if (i != j && num[i][j] == 1) {
                    adj[i].push_back(j);
                }
            }
        }
        vector<int> vis(n, 0);
        int count = 0;
        for (int i = 0; i < n; i++) {
            if (!vis[i]) {
                count++;
                bfs(vis, adj, i);
            }
        }
        return count;
    }
};

// Connected Components Problem in Matrix			

// Method-1
class Solution {
public:
    void dfs(vector<int>& vis, vector<vector<int>> adj, int i) {
        vis[i] = 1;
        for (auto i : adj[i]) {
            if (vis[i] == 0) {
                vis[i] = 1;
                dfs(vis, adj, i);
            }
        }
    }
    int findCircleNum(vector<vector<int>>& num) {
        int n = num.size();
        vector<vector<int>> adj(n);
        for (int i = 0; i < num.size(); i++) {
            for (int j = 0; j < num[i].size(); j++) {
                if (i != j && num[i][j] == 1) {
                    adj[i].push_back(j);
                }
            }
        }
        vector<int> vis(n, 0);
        int count = 0;
        for (int i = 0; i < n; i++) {
            if (!vis[i]) {
                dfs(vis, adj, i);
                count++;
            }
        }
        return count;
    }
};

// Method-2
class Solution {
public:
    void bfs(vector<int>& vis, vector<vector<int>> adj, int i) {
        queue<int> q;
        q.push(i);
        vis[i] = 1;
        while(!q.empty()){
            int f = q.front();
            q.pop();
            for(auto x : adj[f]){
                if(!vis[x]){
                    vis[x] = 1;
                    q.push(x);
                }
            }
        }
    }
    int findCircleNum(vector<vector<int>>& num) {
        int n = num.size();
        vector<vector<int>> adj(n);
        for (int i = 0; i < num.size(); i++) {
            for (int j = 0; j < num[i].size(); j++) {
                if (i != j && num[i][j] == 1) {
                    adj[i].push_back(j);
                }
            }
        }
        vector<int> vis(n, 0);
        int count = 0;
        for (int i = 0; i < n; i++) {
            if (!vis[i]) {
                count++;
                bfs(vis, adj, i);
            }
        }
        return count;
    }
};

// Rotten Oranges		
	
class Solution {
public:
    int orangesRotting(vector<vector<int>>& grid) {
        int m = grid.size();
        int n = grid[0].size();
        vector<vector<int>> visited = grid;
        queue<pair<int, int>> q;
        int countFreshOrange = 0;
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (visited[i][j] == 2) {
                    q.push({i, j});
                }
                if (visited[i][j] == 1) {
                    countFreshOrange++;
                }
            }
        }
        // q.empty() means there is no rotten orange in the grid and
        // countFreshOrange = 0 means we will rotten the freshoranges in 0 mins
        if (countFreshOrange == 0)
            return 0;
        if (q.empty())
            return -1;
        int minutes = -1;
        // we will cover four directions i.e. up, down, left, right
        vector<pair<int, int>> dirs = {{1, 0}, {-1, 0}, {0, -1}, {0, 1}};
        while (!q.empty()) {
            int size = q.size();
            while (size--) {
                auto [x, y] = q.front();
                q.pop();
                for (auto [dx, dy] : dirs) {
                    int i = x + dx;
                    int j = y + dy;
                    if (i >= 0 && i < m && j >= 0 && j < n && visited[i][j] == 1) {
                        visited[i][j] = 2;
                        countFreshOrange--;
                        q.push({i, j});
                    }
                }
            }
            minutes++;
        }
        if (countFreshOrange == 0)
            return minutes;
        return -1;
    }
};

// Flood fill		
	
class Solution {
public:
    void dfs(vector<vector<int>>& image, int i, int j, int val, int newColor) {
        if (i < 0 || i >= image.size() || j < 0 || j >= image[0].size() || image[i][j] == newColor || image[i][j] != val) {
            return;
        }
        image[i][j] = newColor;
        dfs(image, i - 1, j, val, newColor);
        dfs(image, i + 1, j, val, newColor);
        dfs(image, i, j - 1, val, newColor);
        dfs(image, i, j + 1, val, newColor);
    }
    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int newColor) {
        int val = image[sr][sc];
        dfs(image, sr, sc, val, newColor);
        return image;
    }
};

// Cycle Detection in unirected Graph (BFS)

class Graph {
private:
    bool checkForCycle(int s, int V, vector<int> adj[], vector<int>& visited) {
        vector<int> parent(V, -1);
        queue<pair<int, int>> q;
        visited[s] = true;
        q.push({s, -1});
        while (!q.empty()) {
            int node = q.front().first;
            int par = q.front().second;
            q.pop();
            for (auto it : adj[node]) {
                if (!visited[it]) {
                    visited[it] = true;
                    q.push({it, node});
                } else if (par != it) {
                    return true;
                }
            }
        }
        return false;
    }
public:
    bool detectCycle(int V, vector<int> adj[]) {
        vector<int> vis(V, 0);
        for (int i = 0; i < V; i++) {
            if (!vis[i]) {
                if (checkForCycle(i, V, adj, vis)) 
                    return true;
            }
        }
        return false;
    }
};


// Cycle Detection in undirected Graph (DFS)

class Graph {
private:
    bool dfs(int node, int parent, int vis[], vector<int> adj[]){
        vis[node] = 1;
        for(auto i : adj[node]){
            if(!vis[i]){
                if(dfs(i, node, vis, adj)) 
                    return true;
            }
            else if(i != parent) 
                return true;
        }
        return false;
    }
public:
    bool detectCycle(int V, vector<int> adj[]) {
        int vis[V] = { 0 };
        for(int i = 0; i < V; i++){
            if(!vis[i]){
                if(dfs(i, -1, vis, adj)) 
                    return true;
            }
        }
        return false;
    }
};

// 0/1 Matrix (Bfs Problem)		
	
class Solution {
public:
    vector<vector<int>> updateMatrix(vector<vector<int>>& mat) {
        int m = mat.size();
        int n = mat[0].size();
        vector<vector<int>> res(m, vector<int> (n, -1));
        queue<pair<int, int>> q;
        for(int i = 0; i < m; i++){
            for(int j = 0; j < n; j++){
                if(mat[i][j] == 0){
                    res[i][j] = 0;
                    q.push({i, j});
                }
            }
        }
        vector<vector<int>> dir = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};
        while(!q.empty()){
            pair<int, int> p = q.front();
            q.pop();
            int i = p.first;
            int j = p.second;
            for(auto &d : dir){
                int new_i = i + d[0];
                int new_j = j + d[1];
                if(new_i >=0 && new_i < m && new_j >= 0 && new_j < n && res[new_i][new_j] == -1){
                    res[new_i][new_j] = res[i][j] + 1;
                    q.push({new_i, new_j});
                }
            }
        }
        return res;
    }
};

// Surrounded Regions (dfs)		
	
class Solution {
public:
    void dfs(vector<vector<char>>& board, int i, int j, bool& flip, vector<vector<bool>>& visited) {
        if (i >= 0 && i < board.size() && j >= 0 && j < board[0].size() && !visited[i][j]) {
            visited[i][j] = true;
            if (i == 0 || i == board.size() - 1 || j == 0 || j == board[0].size() - 1) {
                if (board[i][j] != 'X') {
                    flip = false;
                }
            }
            if (board[i][j] != 'O') {
                return;
            }
            dfs(board, i - 1, j, flip, visited);
            dfs(board, i + 1, j, flip, visited);
            dfs(board, i, j - 1, flip, visited);
            dfs(board, i, j + 1, flip, visited);
        }
    }
    void fill(vector<vector<char>>& board, int i, int j) {
        if (i >= 0 && i < board.size() && j >= 0 && j < board[i].size() && board[i][j] != 'X') {
            board[i][j] = 'X';
            fill(board, i - 1, j);
            fill(board, i + 1, j);
            fill(board, i, j - 1);
            fill(board, i, j + 1);
        }
    }
    void solve(vector<vector<char>>& board) {
        for (int i = 1; i < board.size() - 1; i++) {
            for (int j = 1; j < board[i].size() - 1; j++) {
                if (board[i][j] == 'O') {
                    bool flip = true;
                    vector<vector<bool>> visited(board.size(), vector<bool>(board[0].size(), false));
                    dfs(board, i, j, flip, visited);
                    if (flip) {
                        fill(board, i, j);
                    }
                }
            }
        }
    }
};

// Number of Enclaves [flood fill implementation-multisource)		
	
class Solution {
public:
    bool isValid(int i, int j, int m, int n, vector<vector<int>>& grid){
        if(i >= 0 && i < m && j >= 0 && j < n && grid[i][j] == 1){
            return true;
        }
        return false;
    }
    void dfs(int i, int j, int m, int n, vector<vector<int>>& grid){
        grid[i][j] = 0;
        vector<vector<int>> dir = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};
        for(auto &d : dir){
            int new_i = i + d[0];
            int new_j = j + d[1];
            if(isValid(new_i, new_j, m, n, grid)){
                dfs(new_i, new_j, m, n, grid);
            }
        }
    }
    int numEnclaves(vector<vector<int>>& grid) {
        int m = grid.size();
        int n = grid[0].size();
        for(int i = 0; i < m; i++){
            for(int j = 0; j < n; j++){
                if((i == 0 || i == m - 1 || j == 0 || j == n - 1) && grid[i][j] == 1){
                    dfs(i, j, m, n, grid);
                }
            }
        }
        int ans = 0;
        for(int i = 0; i < m; i++){
            for(int j = 0; j < n; j++){
                if(grid[i][j] == 1){
                    ans++;
                }
            }
        }
        return ans;
    }
};

// Word ladder - 1		
	
class Solution {
public:
    int ladderLength(string beginWord, string endWord, vector<string>& wordList) {
        queue<pair<string, int>> q;
        q.push({beginWord, 1});
        unordered_set<string> st(wordList.begin(), wordList.end());
        st.erase(beginWord);
        while(!q.empty()){
            string word = q.front().first;
            int steps = q.front().second;
            q.pop();
            if(word == endWord){
                return steps;
            }
            for(int i = 0; i < word.size(); i++){
                char original = word[i];
                for(char ch = 'a'; ch <= 'z'; ch++){
                    word[i] = ch;
                    if(st.find(word) !=st.end()){
                        st.erase(word);
                        q.push({word, steps + 1});
                    }
                }
                word[i] = original;
            }
        }
        return 0;
    }
};

// Word ladder - 2		
	


// Number of Distinct Islands [dfs multisource]

class Solution {
public:
    bool isvalid(int i, int j, int n, int m) {
        return i >= 0 && i < n && j >= 0 && j < m;
    }
    vector<pair<int, int>> moves = {{1, 0}, {0, 1}, {-1, 0}, {0, -1}};
    void dfs(int i, int j, vector<vector<int>>& grid, vector<vector<int>>& vis, vector<pair<int, int>>& ar, int x, int y) {
        int n = grid.size();
        int m = grid[0].size();
        vis[i][j] = 1;
        ar.push_back({i - x, j - y});
        for (auto child : moves) {
            int p = i + child.first;
            int q = j + child.second;
            if (!isvalid(p, q, n, m))
                continue;
            if (grid[p][q] == 0)
                continue;
            if (!vis[p][q]) {
                dfs(p, q, grid, vis, ar, x, y);
            }
        }
    }
    int countDistinctIslands(vector<vector<int>>& grid) {
        int n = grid.size();
        int m = grid[0].size();
        vector<vector<int>> vis(n, vector<int>(m, 0));
        set<vector<pair<int, int>>> s;
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                if (!vis[i][j] && grid[i][j] == 1) {
                    vector<pair<int, int>> ar;
                    dfs(i, j, grid, vis, ar, i, j);
                    s.insert(ar);
                }
            }
        }
        return s.size();
    }
};

// Bipartite Graph
	
// BFS
class Solution {
public:
    bool bfs(int node, vector<vector<int>>& graph, vector<int>& color, vector<int>& vis) {
        queue<int> q;
        q.push(node);
        vis[node] = 1;
        color[node] = 1;
        while (!q.empty()) {
            int curr = q.front();
            q.pop();
            for (int i = 0; i < graph[curr].size(); i++) {
                int adjNode = graph[curr][i];
                if (!vis[adjNode]) {
                    if (color[curr] == color[adjNode]) {
                        color[adjNode] = (-1 * color[curr]);
                    }
                    vis[adjNode] = 1;
                    q.push(adjNode);
                }
                if (vis[adjNode] && color[adjNode] == color[curr])
                    return false;
                }
        }
        return true;
    }
    bool isBipartite(vector<vector<int>>& graph) {
        int n = graph.size();
        vector<int> color(n, -1);        
        vector<int> vis(n, 0);
        bool ans = true;
        for (int i = 0; i < n; i++) {
            if (!vis[i]) {
                bool temp = bfs(i, graph, color, vis);
                ans = ans & temp;
            }
        }
        return ans;
    }
};

// DFS
class Solution {
public:
    bool dfs(int node, int parent, vector<vector<int>>& graph, vector<int>& color) {
        if (parent == -1 || color[parent] == 2) {
            color[node] = 1;
        } else {
            color[node] = 2;
        }
        for (auto ngr : graph[node]) {
            if (color[ngr] == -1) {
                if (dfs(ngr, node, graph, color) == false)
                    return false;
            } else if (color[ngr] == color[node])
                return false;
        }
        return true;
    }
    bool isBipartite(vector<vector<int>>& graph) {
        int n = graph.size();
        vector<int> color(n, -1);
        for (int i = 0; i < n; i++) {
            if (color[i] == -1 && dfs(i, -1, graph, color) == false)
                return false;
        }
        return true;
    }
};

// Cycle Detection in Directed Graph (DFS)

#include <bits/stdc++.h>
bool dfs(int node, vector<int> adj[], int vis[], int pathvis[]){
    vis[node] = 1;
    pathvis[node] = 1;
    for (auto it : adj[node]){
        if (!vis[it]){
        if (dfs(it, adj, vis, pathvis) == true)
            return true;
        }
        else if (pathvis[it]){
        return true;
        }
    }
    pathvis[node] = 0;
    return false;
}
bool isCyclic(vector<vector<int>> &edges, int v, int e){
    int n = v;
    vector<int> adj[n];
    for (auto i : edges)
        adj[i[0]].push_back(i[1]);
    int vis[n] = {0};
    int pathvis[n] = {0};
    for (int i = 0; i < n; i++){
        if (!vis[i]){
            if (dfs(i, adj, vis, pathvis) == true)
                return true;
            }
    }
    return false;
}

/* Step 15.3: Topo Sort and Problems */

// Topo Sort		

#include <bits/stdc++.h>
void dfs(int node, vector<int> adj[], int vis[], stack<int>& st){
    vis[node] = 1;
    for(auto it : adj[node]){
        if(!vis[it]){
            dfs(it, adj, vis, st);
        }
    }
    st.push(node);
}
vector<int> topologicalSort(vector<vector<int>> &graph, int edges, int nodes) {
    vector<int> adj[nodes];
    for(auto it : graph){
        adj[it[0]].push_back(it[1]);
    }
    int vis[nodes] = {0};
    stack<int> st;
    for(int i = 0; i < nodes; i++){
        if(!vis[i]){
            dfs(i, adj, vis, st);
        }
    }
    vector<int> ans;
    for(int i = 0; i < nodes; i++){
        ans.push_back(st.top());
        st.pop();
    }
    return ans;
}

// Kahn's Algorithm		

#include <vector>
#include <queue>
vector<int> topologicalSort(vector<vector<int>> &graph, int edges, int nodes) {
    vector<int> indegree(nodes, 0);
    vector<vector<int>> adj(nodes);
    for(auto it : graph){
        adj[it[0]].push_back(it[1]);
        indegree[it[1]]++;
    }
    queue<int> q;
    for(int i = 0; i < nodes; i++){
        if(indegree[i] == 0) 
            q.push(i);
    }
    vector<int> topo;
    while(!q.empty()){
        int node = q.front();
        q.pop();
        topo.push_back(node);
        for(auto it : adj[node]){
            indegree[it]--;
            if(indegree[it] == 0) 
                q.push(it);
        }
    }
    return topo;
}

// Cycle Detection in Directed Graph (BFS)

#include<queue>
bool isCyclic(vector<vector<int>> &edges, int v, int e) {
    vector<int> adj[v];
    for (auto it : edges) {
        int from = it[0];
        int to = it[1];
        adj[from].push_back(to);
    }
    int indegree[v] = {0};
    for (int i = 0; i < v; i++) {
        for (auto it : adj[i])
        indegree[it]++;
    }
    queue<int> q;
    for (int i = 0; i < v; i++) {
        if (indegree[i] == 0)
        q.push(i);
    }
    int cnt = 0;
    while (!q.empty()) {
        int node = q.front();
        q.pop();
        cnt++;
        for (auto it : adj[node]) {
        indegree[it]--;
        if (indegree[it] == 0)
            q.push(it);
        }
    }
    if (cnt == v)
        return false;
    return true;
}

// Course Schedule - I		
	
class Solution {
public:
    bool iscycle(vector<int> adj[], vector<int>& vis, int id) {
        if (vis[id] == 1) {
            return true;
        }
        if (vis[id] == 0) {
            vis[id] = 1; // mark the current node as visited(in process)
            // recursively check for cycles in the adjacent nodes
            for (auto edge : adj[id]) {
                if (iscycle(adj, vis, edge)) {
                    return true;
                }
            }
        }
        vis[id] = 2; // mark the current node as visited(processed)
        return false;
    }
    bool canFinish(int n, vector<vector<int>>& pre) {
        vector<int> adj[n];
        for (auto edge : pre) {
            adj[edge[1]].push_back(edge[0]);
        }
        vector<int> vis(n, 0);
        for (int i = 0; i < n; i++) {
            if (iscycle(adj, vis, i)) {
                return false;
            }
        }
        return true;
    }
};

// Course Schedule - II		
	
class Solution {
public:
    vector<int> findOrder(int numCourses, vector<vector<int>>& pre) {
        // created the adj matrix
        vector<vector<int>> adj_matrix(numCourses, vector<int>(numCourses, 0));
        // bi-->ai
        for (int i = 0; i < pre.size(); i++) {
            adj_matrix[pre[i][1]][pre[i][0]] = 1;
        }
        // we have prepared the adj matrix all we have to do is now find the toplogical sorting of the graph
        // if there exist any
        stack<int> topo_ordering;
        vector<int> indegree(numCourses, 0);
        // find all the nodes indegree or in other words number of dependencies they have
        for (int i = 0; i < numCourses; i++) {
            for (int j = 0; j < numCourses; j++) {
                // i--j means i must be come before j then j has a dependency
                if (adj_matrix[i][j])
                    indegree[j]++;
            }
        }
        // now if there are any nodes with indegree 0 they are free from dependencies they can come in any order
        for (int i = 0; i < numCourses; i++) {
            if (indegree[i] == 0)
                topo_ordering.push(i);
        }
        vector<int> ans;
        // say if there are no such nodes dependency free then there is no ordering
        while (!topo_ordering.empty() ) {
            int temp = topo_ordering.top();
            topo_ordering.pop();
            ans.push_back(temp);
            for (int i = 0; i < numCourses; i++) {
                if (adj_matrix[temp][i]) {
                    indegree[i]--;
                    if (indegree[i] == 0) {
                        topo_ordering.push(i);
                    }
                }
            }
        }
        if (ans.size() != numCourses)
            return {};
        return ans;
    }
};

// Find eventual safe states		
	
// BFS
class Solution {
public:
    vector<int> eventualSafeNodes(vector<vector<int>>& graph) {
        int V = graph.size();
        vector<int> res;
        vector<int> indeg(V, 0);
        vector<vector<int>> adj(V, vector<int>());
        for (int i = 0; i < V; i++) {
            for (auto e : graph[i]) {
                adj[e].push_back(i);
                indeg[i]++;
            }
        }
        queue<int> q;
        for (int i = 0; i < V; i++) {
            if (indeg[i] == 0)
                q.push(i);
        }
        while (!q.empty()) {
            int node = q.front();
            q.pop();
            res.push_back(node);
            for (auto i : adj[node]) {
                indeg[i]--;
                if (indeg[i] == 0)
                    q.push(i);
            }
        }
        sort(res.begin(), res.end());
        return res;
    }
};

// DFS
class Solution {
public:
    bool detectCycle(int v, vector<vector<int>>& graph, vector<int>& vis, vector<int>& pathVis) {
        vis[v] = 1;
        pathVis[v] = 1;
        for (auto& nb : graph[v]) {
            if (vis[nb] == 0) {
                if (detectCycle(nb, graph, vis, pathVis))
                    return true;
            } else {
                if (pathVis[nb] == 1) {
                    return true;
                }
            }
        }
        pathVis[v] = 0;
        return false;
    }
    vector<int> eventualSafeNodes(vector<vector<int>>& graph) {
        int v = graph.size();
        vector<int> ans;
        vector<int> vis(v, 0);
        vector<int> pathVis(v, 0);
        for (int i = 0; i < v; i++) {
            if (!detectCycle(i, graph, vis, pathVis)) {
                ans.push_back(i);
            }
        }
        return ans;
    }
};

// Alien dictionary		
	
class Solution{
public:
    void addEdge(vector<int> adj[], string s, string t) {
        int i = 0, j = 0;
        while (i < s.length() && j < t.length() && s[i] == t[j]) {
            i++;
            j++;
        }
        if (i < s.length() && j < t.length()) {
            adj[s[i] - 'a'].push_back(t[j] - 'a');
        }
    }
    void topologicalSortUtil(int v, vector<int> adj[], vector<bool>& visited, stack<int>& s) {
        visited[v] = true;
        for (int i = 0; i < adj[v].size(); i++) {
            int u = adj[v][i];
            if (!visited[u]) {
                topologicalSortUtil(u, adj, visited, s);
            }
        }
        s.push(v);
    }
    string findOrder(string dict[], int N, int K) {
        vector<int> adj[K];
        for (int i = 0; i < N - 1; i++) {
            addEdge(adj, dict[i], dict[i + 1]);
        }
        vector<bool> visited(K, false);
        stack<int> s;
        for (int i = 0; i < K; i++) {
            if (!visited[i]) {
                topologicalSortUtil(i, adj, visited, s);
            }
        }
        string ans = "";
        while (!s.empty()) {
            ans += (char)(s.top() + 'a');
            s.pop();
        }
        return ans;
    }
};

/* Step 15.4: Shortest Path Algorithms and Problems */

// Shortest Path in UG with unit weights

vector<int> shortestPath(int n, vector<vector<int>> &edges, int src) {
    vector<int> adj[n];
    for (int i = 0; i < edges.size(); i++) {
        int u = edges[i][0];
        int v = edges[i][1];
        adj[u].push_back(v);
        adj[v].push_back(u);
    }
    vector<int> distance(n, -1);
    distance[src] = 0;
    queue<int> q;
    q.push(src);
    while (!q.empty()) {
        int node = q.front();
        q.pop();
        for (auto &child : adj[node]) {
            if (distance[child] == -1) {
                distance[child] = distance[node] + 1;
                q.push(child);
            }
        }
    }
    return distance;
}

// Shortest Path in DAG		

vector<int> shortestPathInDAG(int n, int m, vector<vector<int>> &edges){
    vector<vector<pair<int,int>>> adj(n);
    for(int i=0;i<m;i++){
        int u=edges[i][0];
        int v=edges[i][1];
        int w=edges[i][2];
        adj[u].push_back({v,w});
    }
    queue<pair<int,int>> q;
    vector<int> distance(n,INT_MAX);
    q.push({0,0});
    distance[0]=0;
    while(!q.empty()){
        pair<int,int> front=q.front();
        int node=front.first;
        int dist=front.second;
        q.pop();
        for(auto i:adj[node]){
            if(distance[i.first]>(i.second+dist)){
                distance[i.first]=i.second+dist;
                q.push({i.first,distance[i.first]});
            }
        }
    }
    for(int i=0;i<n;i++){
        if(distance[i]==INT_MAX){
            distance[i]=-1;
        }
    }
    return distance;
}

// Djisktra's Algorithm		

#include<bits/stdc++.h>
vector<int> dijkstra(vector<vector<int>> &vec, int vertices, int edges, int source) {
    unordered_map<int, list<pair<int, int> > > adj;
    for(int i = 0; i < edges; i++){
        int u = vec[i][0];
        int v = vec[i][1];
        int w = vec[i][2];
        adj[u].push_back(make_pair(v,w));
        adj[v].push_back(make_pair(u,w));
    }
    vector<int> dis(vertices);
    for(int i = 0; i < vertices; i++)
        dis[i] = INT_MAX;
    set<pair<int, int> > st;
    st.insert(make_pair(0, source));
    dis[source] = 0;
    while(!st.empty()){
        auto top = *(st.begin());
        int nodeDis = top.first;
        int topnode = top.second;
        st.erase(st.begin());        
        for(auto neighbour : adj[topnode]){
            if(nodeDis + neighbour.second < dis[neighbour.first]){
                auto record = st.find(make_pair(dis[neighbour.first], neighbour.first));
                if(record != st.end())
                    st.erase(record);
                dis[neighbour.first] = nodeDis + neighbour.second;
                st.insert(make_pair(dis[neighbour.first], neighbour.first));
            }
        }
    }
    return dis;
}

// Why priority Queue is used in Djisktra Algorithm		

vector<int> dijkstra(vector<vector<int>> &edge, int vertices, int edges, int source){
    vector<vector<int>> adj[vertices];
    for(auto it : edge){
        int node = it[0];
        int adjNode = it[1];
        int len = it[2];
        adj[node].push_back({adjNode,len});
        adj[adjNode].push_back({node,len});
    }
    priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>>pq;
    vector<int>dist(vertices,1e9);
    dist[source] = 0;
    pq.push({0,source});
    while(!pq.empty()){
        int node = pq.top().second;
        int len = pq.top().first;
        pq.pop();
        for(auto it : adj[node]){
            int adjNode = it[0];
            int adjDis = it[1];
            if(len + adjDis < dist[adjNode]){
                dist[adjNode] = len + adjDis;
                pq.push({dist[adjNode],adjNode});
            }
        }
    }
    return dist;
}

// Shortest path in a binary maze		
	
class Solution {
public:
    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {
        queue<pair<int, pair<int, int>>> q; // Queue to store distance and coordinates
        int n = grid.size();
        int m = grid[0].size();
        // Check if starting cell is blocked
        if (grid[0][0] == 1)
            return -1;
        // Check if destination cell is blocked
        if (grid[n - 1][m - 1] == 1)
            return -1;
        // If there is only one cell and it is reachable
        if (n == 1 && grid[0][0] == 0)
            return 1;
        // Push the starting cell into the queue with distance 1
        q.push({1, {0, 0}});
        // Array to represent movements in row and column directions
        int delRow[] = {-1, 0, 1, 0, 1, -1, -1, 1};
        int delCol[] = {0, 1, 0, -1, 1, 1, -1, -1};
        while (!q.empty()) {
            int dis = q.front().first; // Distance of current cell from the starting cell
            int row = q.front().second.first; // Row index of current cell
            int col = q.front().second.second; // Column index of current cell
            q.pop(); // Remove the current cell from the queue
            // Check all eight neighboring cells
            for (int i = 0; i < 8; i++) { // Loop through neighbors
                int newRow = row + delRow[i]; // Calculate new row index
                int newCol = col + delCol[i]; // Calculate new column index
                // Check if the new cell is within the grid boundaries and is unblocked
                if (newRow >= 0 && newRow < n && newCol >= 0 && newCol < m && grid[newRow][newCol] == 0) {
                    // Mark the cell as visited (-1) to avoid revisiting
                    grid[newRow][newCol] = -1;
                    // If the new cell is the destination, return the distance + 1
                    if (newRow == n - 1 && newCol == m - 1) {
                        return dis + 1;
                    }
                    // Push the new cell into the queue with distance incremented by 1
                    q.push({dis + 1, {newRow, newCol}});
                }
            }
        }
        // If destination cell is unreachable or there is no path, return -1
        return -1;
    }
};

// Path with minimum effort	
	
class Solution {
public:
    int minimumEffortPath(vector<vector<int>>& heights) {
        priority_queue<pair<int, pair<int, int>>, vector<pair<int, pair<int, int>>>, greater<pair<int, pair<int, int>>>> pq;
        int n = heights.size();
        int m = heights[0].size();
        vector<vector<int>> dist(n, vector<int>(m, 1e9));
        dist[0][0] = 0;
        pq.push({0, {0, 0}});
        int delR[] = {-1, 0, 1, 0};
        int delC[] = {0, 1, 0, -1};
        while (!pq.empty()) {
            auto it = pq.top();
            pq.pop();
            int difference = it.first;
            int r = it.second.first;
            int c = it.second.second;
            if (r == n - 1 && c == m - 1)
                return difference;
            for (int i = 0; i < 4; i++) {
                int nr = r + delR[i];
                int nc = c + delC[i];
                if (nr >= 0 && nr < n && nc >= 0 && nc < m) {
                    int newEffort;
                    newEffort = max((abs(heights[r][c] - heights[nr][nc])), difference);
                    if (newEffort < dist[nr][nc]) {
                        dist[nr][nc] = newEffort;
                        pq.push({newEffort, {nr, nc}});
                    }
                }
            }
        }
        return 0;
    }
};

// Cheapest flights within k stops		
	
class Solution {
public:
    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {
        vector<int> distance(n, INT_MAX);
        unordered_map<int, vector<pair<int, int>>> adj;
        for (vector<int>& a : flights) {
            int u = a[0];
            int v = a[1];
            int cost = a[2];
            adj[u].push_back({v, cost});
        }
        queue<pair<int, int>> q;
        q.push({src, 0});
        int steps = 0;
        while (!q.empty() && steps <= k) {
            int size = q.size();
            while (size--) {
                int u = q.front().first;
                int d = q.front().second;
                q.pop();
                for (pair<int, int>& p : adj[u]) {
                    int v = p.first;
                    int cost = p.second;
                    if (distance[v] > d + cost) {
                        distance[v] = d + cost;
                        q.push({v, d + cost});
                    }
                }
            }
            steps++;
        }
        return distance[dst] == INT_MAX ? -1 : distance[dst];
    }
};

// Network Delay time				

class Solution {
public:
    int networkDelayTime(vector<vector<int>>& times, int n, int k) {
        vector<pair<int, int>> adj[n + 1];
        for (auto it : times) {
            int u = it[0];  // source node
            int v = it[1];  // destination node
            int wt = it[2]; // weight or time taken to travel from u to v
            adj[u].push_back({v, wt});
        }
        // Create a priority queue for Dijkstra's algorithm
        // Pair (time, node) is used where 'time' represents time taken to reach
        // 'node' and 'node' represents the node number
        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;
        // Push the source node 'k' with time 0 to the priority queue
        pq.push({0, k});
        // Initialize an array to keep track of minimum distances from the source node 'k' to all other nodes
        vector<int> dist(n + 1, INT_MAX);
        dist[k] = 0; // Distance from 'k' to itself is 0
        while (!pq.empty()) {
            int time = pq.top().first;  // Time taken to reach the current node
            int node = pq.top().second; // Current node
            pq.pop();
            // Iterate over all adjacent nodes of the current node
            for (auto it : adj[node]) {
                int neighbourNode = it.first; // Neighbouring node
                int wt = it.second; // Weight of the edge between 'node' and 'neighbourNode'
                // If the total time taken to reach 'neighbourNode' through
                // 'node' is less than the current recorded distance to
                // 'neighbourNode', update the distance
                if (time + wt < dist[neighbourNode]) {
                    dist[neighbourNode] = time + wt;
                    // Push the updated distance and the neighbouring node to the priority queue
                    pq.push({dist[neighbourNode], neighbourNode});
                }
            }
        }
        // Find the maximum distance in 'dist' array
        int mx = *max_element(dist.begin() + 1, dist.end());
        // If mx is still INT_MAX, it means some nodes are not reachable from
        // the source 'k', so return -1, otherwise return the maximum distance
        return mx == INT_MAX ? -1 : mx;
    }
};

// Number of ways to arrive at destination		
	
#define ll long long
class Solution {
public:
    int M = 1e9 + 7;
    int countPaths(int n, vector<vector<int>>& roads) {
        ll src = 0;
        // create an adjancy list
        vector<pair<ll, ll>> adj[n];
        for (auto it : roads) {
            int u = it[0];
            int v = it[1];
            int wt = it[2];
            adj[u].push_back({v, wt});
            adj[v].push_back({u, wt});
        }
        // time is very --> so we use the  priority queue..
        priority_queue<pair<ll, ll>, vector<pair<ll, ll>>, greater<pair<ll, ll>>> pq;
        // push the things--> {dis ,node}
        pq.push({0, 0});
        // make the distance vector
        vector<ll> dist(n, LLONG_MAX);
        dist[src] = 0;
        // make the ways vector
        vector<ll> ways(n, 0);
        ways[src] = 1;
        while (!pq.empty()) {
            ll dis = pq.top().first;
            ll curr_node = pq.top().second;
            pq.pop();
            for (auto it : adj[curr_node]) {
                ll neighnode = it.first;
                ll wt = it.second;
                if (dis + wt < dist[neighnode]) {
                    dist[neighnode] = dis + wt;
                    pq.push({dist[neighnode], neighnode});
                    ways[neighnode] = ways[curr_node];
                }
                else if (dis + wt == dist[neighnode]) {
                    ways[neighnode] = (ways[neighnode] + ways[curr_node]) % M;
                }
            }
        }
        return ways[n - 1] % M;
    }
};

// Minimum multiplications to reach end		

int minimumOperations(int n, int start, int end, vector<int> &a){
    vector<bool> visited(1000,false);
    queue<pair<int,int>> q;
    q.push({0,start});
    visited[start] = true;
    while(!q.empty()){
        int node = q.front().second;
        int dist = q.front().first;
        q.pop();
        if(node == end){
            return dist;
        }
        for(auto i: a){
            int val = (i*node)%1000;
            if(visited[val]==false){
              visited[val] = true;
              q.push({dist+1,val});
            }
        }
    }
    return -1;
}

// Bellman Ford Algorithm		

#include <bits/stdc++.h> 
int bellmonFord(int n, int m, int src, int dest, vector<vector<int>> &edges) {
    vector<int> dist(n+1, 1e9);
    dist[src] = 0;
    for (int i=1; i<=n; i++){
        for (int j=0; j<m; j++){
            int u = edges[j][0];
            int v = edges[j][1];
            int wt = edges[j][2];
            if (dist[u] != 1e9 && ((dist[u]+wt) < dist[v])){
                dist[v] = dist[u]+wt;
            }
        }
    }
    return dist[dest];

    // if -ve cycle is present
    // bool flag = 0;
    // for (int j=0; j<m; j++){
    //     int u = edges[j][0];
    //     int v = edges[j][1];
    //     int wt = edges[j][2];
    //     if (dist[u] != 1e9 && ((dist[u]+wt) < dist[v])){
    //         bool flag = 1;
    //     }
    // }
    // if (flag == 0){
    //     return dist[dest];
    // }
    // return -1;
}


// Floyd Warshal Algorithm		

int floydWarshall(int n, int m, int src, int dest, vector<vector<int>> &edges) {
    vector<vector<int>> matrix(n + 1, vector<int>(n + 1, 1e9));
    for (auto i : edges) {
        matrix[i[0]][i[1]] = i[2];
    }
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= n; j++) {
            if (i == j)
                matrix[i][j] = 0;
        }
    }
    for (int k = 1; k <= n; k++) {
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= n; j++) {
                if (matrix[i][k] != 1e9 && matrix[k][j] != 1e9)
                    matrix[i][j] = min(matrix[i][j], matrix[i][k] + matrix[k][j]);
            }
        }
    }
    return matrix[src][dest];
}

// Find the city with the smallest number of neighbours in a threshold distance		

class Solution {
public:
    int findTheCity(int n, vector<vector<int>>& edges, int distanceThreshold) {
        // Initialising distance array
        vector<vector<int>> dist(n, vector<int>(n, 1e9));
        for (int i = 0; i < n; i++) {
            dist[i][i] = 0;
        }
        // Marking its weight from one city to its neighbour city
        for (auto it : edges) {
            int from = it[0];
            int to = it[1];
            int weight = it[2];
            dist[from][to] = weight;
            dist[to][from] = weight;
        }
        // Implementing Floyd Warshall Algorithm
        for (int thr = 0; thr < n; thr++) {
            for (int i = 0; i < n; i++) {
                for (int j = 0; j < n; j++) {
                    if (dist[i][j] > dist[i][thr] + dist[thr][j]) {
                        dist[i][j] = dist[i][thr] + dist[thr][j];
                    }
                }
            }
        }
        int mincnt = n, city = -1;
        // Finding the no of cities can be reached from each city in the threshold distance
        for (int i = 0; i < n; i++) {
            int cnt = 0;
            for (int j = 0; j < n; j++) {
                if (dist[i][j] <= distanceThreshold) {
                    cnt++;
                }
            }
            if (mincnt >= cnt) {
                mincnt = cnt;
                city = i;
            }
        }
        return city;
    }
};

/* Step 15.5: MinimumSpanningTree/Disjoint Set and Problems */

// Minimum Spanning Tree		



// Prim's Algorithm		



// Disjoint Set [Union by Rank]		



// Disjoint Set [Union by Size]		



// Kruskal's Algorithm		



// Number of operations to make network connected		
	


// Most stones removed with same rows or columns



// Accounts merge		
	


// Number of island II		
	


// Making a Large Island		
	


// Swim in rising water				



/* Step 15.6: Other Algorithms */

// Bridges in Graph		
	


// Articulation Point		



// Kosaraju's Algorithm		

