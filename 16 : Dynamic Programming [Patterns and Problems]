/* 1: Introduction to DP */

// Dynamic Programming Introduction

class Solution {
    // memoization  
    long long int mod= 1e9+7;
    long long int tdown(int n, vector<long long int>& dp){
        if(n <= 1){
            return n;
        }
        if(dp[n] != -1) return dp[n];
        return dp[n] = (tdown(n - 1, dp) + tdown(n - 2, dp)) % mod;
    }
 public:
    long long int topDown(int n) {
        vector<long long int> dp(n + 1, -1);
        return tdown(n, dp);
        //tc: O(n),sc: O(n) + O(n) (stack,array(dp)).
    }
    // most optimized code
    long long int bottomUp(int n) {
        // base case
        if(n <= 1) 
            return n;
        int cur, prev = 1, prev2 = 0;
        for(int i = 2; i <= n; i++){
            cur = (prev + prev2) % mod;
            prev2 = prev;
            prev = cur;
        }
        return cur % mod;
        //tc: O(n),sc: O(1).
    }
};

/* 2: 1D DP */

// Climbing Stars

// Method-1
class Solution {
public:
    int climbStairs(int n, unordered_map<int, int>& memo) {
        if (n == 0 || n == 1) {
            return 1;
        }
        if (memo.find(n) == memo.end()) {
            memo[n] = climbStairs(n-1, memo) + climbStairs(n-2, memo);
        }
        return memo[n];
    }
    int climbStairs(int n) {
        unordered_map<int, int> memo;
        return climbStairs(n, memo);
    }
};

// Method-2
class Solution {
public:
    int climbStairs(int n) {
        // Base case: when n is 0 or 1, there's only one way to climb the stairs
        if (n == 0 || n == 1) {
            cout << "Number of ways to climb " << n << " stairs: " << 1 << endl;
            return 1;
        }
        // Initializing variables to track previous and current steps
        int prev = 1, curr = 1;
        // Iterating from 2 to n, as we already know the number of ways for n = 0 and n = 1
        for (int i = 2; i <= n; i++) {
            // Storing the current value of curr for later use
            int temp = curr;
            // Current number of ways to climb n stairs is the sum of ways to climb (n-1) and (n-2) stairs
            curr = prev + curr;
            // Updating prev for the next iteration
            prev = temp;
            // Printing current number of ways to climb i stairs
            cout << "Number of ways to climb " << i << " stairs: " << curr << endl;
        }
        // Returning the number of ways to climb n stairs
        return curr;
    }
};

// Frog Jump(DP-3)

// Method-1
class Solution {
  public:
    int solve(vector<int>& dp, vector<int>& height, int i){
        if(i < 1){
            return 0;
        }
        if(dp[i] != -1){
            return dp[i];
        }
        int right = INT_MAX;
        int left = solve(dp, height, i - 1) + abs(height[i] - height[i - 1]);
        if(i > 1){
            right = solve(dp, height, i - 2) + abs(height[i] - height[i - 2]);
        }
        dp[i] = min(left, right);
        return dp[i];
    }
    int minimumEnergy(vector<int>& height, int n) {
        vector<int> dp(n + 1, -1);
        return solve(dp, height, n - 1);
    }
};

// Method-2
class Solution {
  public:
     int minimumEnergy(vector<int>& height, int n) {
        int prev = 0;
        int prev2 = 0;
        for(int i=1;i<n;i++){
            int fs = prev + abs(height[i] -height[i-1] );
            int ss = INT_MAX;
            if(i>1){
                ss = prev2 + abs(height[i] -height[i-2] );
            }
            int curr = min(fs,ss);
            prev2 = prev;
            prev = curr;
        }
        return prev;
    }
};

// Frog Jump with k distances(DP-4)

// Method-1
class Solution {
  public:
    int solve(int n, int k, vector<int>& height, vector<int>& dp){
        if(n == 0){
            return 0;
        }
        if(dp[n] != -1){
            return dp[n];
        }
        int mini = INT_MAX;
        for(int i = 1; i <=k; i++){
            if(n - i >= 0){
                int jump = solve(n - i, k, height, dp) + abs(height[n] - height[n - i]);
                mini = min(mini, jump);
            }
        }
        return dp[n] = mini;
    }
    int minimizeCost(vector<int>& height, int n, int k) {
        vector<int> dp(n + 1, -1);
        return solve(n - 1, k, height, dp);
    }
};

// Method-2
class Solution {
  public:
    int minimizeCost(vector<int>& height, int n, int k) {
        vector<int>t(n+1,0);
        for(int i=1;i<=n;i++){
            int mini=INT_MAX;
            for(int j=1;j<=k;j++){
                if(i-j>=0){
                     int jump=abs(height[i]-height[i-j])+t[i-j];
                     mini=min(mini,jump);
                }
            }
        t[i]=mini;
        }
        return t[n-1];
    }
};

// Maximum sum of non-adjacent elements (DP 5)

// method-1
class Solution {
private:
    int solve(int i, vector<int>& nums, vector<int>& dp) {
        if (i == 0) {
            return nums[0];
        }
        if (i < 0) {
            return 0;
        }
        if (dp[i] != -1) {
            return dp[i];
        }
        int pick = nums[i] + solve(i - 2, nums, dp);
        int notPick = 0 + solve(i - 1, nums, dp);
        return dp[i] = max(pick, notPick);
    }
public:
    int rob(vector<int>& nums) {
        int n = nums.size();
        if (n == 1) {
            return nums[0];
        }
        vector<int> dp(n, -1);
        solve(n - 1, nums, dp);
        return dp[n - 1];
    }
};

// Method-2
class Solution{
public:
    int rob(vector<int> &nums){
        int n = nums.size();
        int prev2 = 0, prev = nums[0];
        for (int i = 1; i < n; i++){
            int pick = nums[i] + prev2;
            int notPick = 0 + prev;
            int curr = max(pick, notPick);
            prev2 = prev;
            prev = curr;
        }
        return prev;
    }
};

// House Robber (DP 6)

// Method-1
class Solution {
public:
    int solve(int i, int n, vector<int>& nums, vector<int>& dp) {
        if (i > n) {
            return 0;
        }
        if (dp[i] != -1) {
            return dp[i];
        }
        int pick = nums[i] + solve(i + 2, n, nums, dp);
        int notPick = solve(i + 1, n, nums, dp);
        return dp[i] = max(pick, notPick);
    }
    int rob(vector<int>& nums) {
        int n = nums.size();
        if (n == 1) {
            return nums[0];
        }
        if (n == 2) {
            return max(nums[0], nums[1]);
        }
        vector<int> dp1(n, -1);
        int index1 = solve(0, n - 2, nums, dp1);
        vector<int> dp2(n, -1);
        int index2 = solve(1, n - 1, nums, dp2);
        return max(index1, index2);
    }
};

// Method-2
class Solution {
public:
    int solve(int i, int n, vector<int>& nums) {
        int prevPrev = 0, prev = 0;
        for(int k = i; k <= n; k++){
            int pick = nums[k] + prevPrev;
            int notPick = prev;
            int ans = max(pick, notPick);
            prevPrev = prev;
            prev = ans;
        }
        return prev;
    }
    int rob(vector<int>& nums) {
        int n = nums.size();
        if (n == 1) {
            return nums[0];
        }
        if (n == 2) {
            return max(nums[0], nums[1]);
        }
        int index1 = solve(0, n - 2, nums);
        int indexn = solve(1, n - 1, nums);
        return max(index1, indexn);
    }
};

/* 3: 2D/3D DP and DP on Grids */

// Ninja's Training (DP 7)

// Method-1
class Solution {
  public:
     int solve(vector<vector<int>>& points, vector<vector<int>>&dp, int n, int i){
        if(n==0) return points[0][i];
        if(dp[n][i] != -1) return dp[n][i];
        for(int j=0;j<3;j++){
            if(i!=j)
                dp[n][i] = max(dp[n][i],solve(points,dp,n-1,j)+points[n][i]);
        }
        return dp[n][i];
    }
    int maximumPoints(vector<vector<int>>& points, int n) {
        vector<vector<int>> dp(n+1, vector<int>(3,-1));
        return max(solve(points,dp,n-1,0),max(solve(points,dp,n-1,1),solve(points,dp,n-1,2)));
    }
};

// Method-2
class Solution {
  public:
    int maximumPoints(vector<vector<int>>& points, int n) {
        vector<vector<int>>dp(n+2,vector<int>(4,0));
        dp[1][1]=points[0][0];
        dp[1][2]=points[0][1];
        dp[1][3]=points[0][2];
        int i=2;
        while(i<=n){
            dp[i][1]=points[i-1][0]+max(dp[i-1][2],dp[i-1][3]);
            dp[i][2]=points[i-1][1]+max(dp[i-1][1],dp[i-1][3]);
            dp[i][3]=points[i-1][2]+max(dp[i-1][2],dp[i-1][1]);
            i++;
        }
        return max({dp[n][1],dp[n][2],dp[n][3]});
    }
};

// Grid Unique Paths : DP on Grids (DP8)

// Method-1
class Solution {
public:
    int uniquePaths(int m, int n) {
        // Create a memoization table to store computed results
        vector<vector<int>> memo(m, vector<int>(n, -1));
        // Call the recursive function to compute unique paths
        return uniquePathsRecursive(0, 0, m, n, memo);
    }
    int uniquePathsRecursive(int x, int y, int m, int n, vector<vector<int>>& memo) {
        // If we reach the destination (bottom-right corner), return 1
        if (x == m - 1 && y == n - 1) {
            return 1;
        }
        // If we have already computed the result for this cell, return it from the memo table
        if (memo[x][y] != -1) {
            return memo[x][y];
        }
        // Calculate the number of unique paths by moving right and down
        int rightPaths = 0;
        int downPaths = 0;
        // Check if it's valid to move right
        if (x < m - 1) {
            rightPaths = uniquePathsRecursive(x + 1, y, m, n, memo);
        }
        // Check if it's valid to move down
        if (y < n - 1) {
            downPaths = uniquePathsRecursive(x, y + 1, m, n, memo);
        }
        // Store the result in the memo table and return it
        memo[x][y] = rightPaths + downPaths;
        return memo[x][y];
    }
};

// Method-2
class Solution {
public:
    int uniquePaths(int m, int n) {
        vector<vector<int>> dp(m, vector<int>(n, 0));
        // Initialize the rightmost column and bottom row to 1 because there is
        // only one way to reach each cell in those rows/columns.
        for (int i = 0; i < m; i++) {
            dp[i][n - 1] = 1;
        }
        for (int j = 0; j < n; j++) {
            dp[m - 1][j] = 1;
        }
        // Fill in the dp table bottom-up
        for (int i = m - 2; i >= 0; i--) {
            for (int j = n - 2; j >= 0; j--) {
                dp[i][j] = dp[i + 1][j] + dp[i][j + 1];
            }
        }
        return dp[0][0];
    }
};

// Method-3
class Solution {
public:
    int uniquePaths(int m, int n) {
        if (m <= 0 || n <= 0)
            return 0;
        long long res = 1;
        for (int i = n; i < m + n - 1; i++) {
            res = res * i / (i - n + 1);
        }
        return (int)res;
    }
};

// Grid Unique Paths 2 (DP 9)

// Method-1
class Solution {
public:
    int solve(int i, int j, int m, int n, vector<vector<int>>& obstacleGrid, vector<vector<int>>& dp) {
        if (i < 0 || i >= m || j < 0 || j >= n || obstacleGrid[i][j] == 1) {
            return 0;
        }
        if (i == m - 1 && j == n - 1) {
            return 1;
        }
        if (dp[i][j] != -1) {
            return dp[i][j];
        }
        int right = solve(i, j + 1, m, n, obstacleGrid, dp);
        int down = solve(i + 1, j, m, n, obstacleGrid, dp);
        return dp[i][j] = right + down;
    }
    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {
        int m = obstacleGrid.size(), n = obstacleGrid[0].size();
        vector<vector<int>> dp(m, vector<int>(n, -1));
        if (obstacleGrid[m - 1][n - 1] == 1) {
            return 0;
        }        
        return solve(0, 0, m, n, obstacleGrid, dp);
    }
};

// Method-2
class Solution {
public:
    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {
        int m = obstacleGrid.size(), n = obstacleGrid[0].size();
        if (obstacleGrid[0][0] == 1 || obstacleGrid[m - 1][n - 1] == 1)
            return 0;
        vector<int> dp(n);
        dp[0] = 1;
        for (int i = 1; i < n; i++) {
            dp[i] = (obstacleGrid[0][i] ^ 1) & dp[i - 1];
        }
        for (int i = 1; i < m; i++) {
            int prev = 0;
            for (int j = 0; j < n; j++) {
                if (obstacleGrid[i][j])
                    dp[j] = 0;
                else
                    dp[j] += prev;
                prev = dp[j];
            }
        }
        return dp[n - 1];
    }
};

// Method-3
class Solution {
public:
    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {
        int m = obstacleGrid.size(), n = obstacleGrid[0].size();
        if (obstacleGrid[0][0] == 1 || obstacleGrid[m - 1][n - 1] == 1)
            return 0;
        vector<int> dp(n);
        dp[0] = 1;
        for (int i = 1; i < n; i++) {
            dp[i] = (obstacleGrid[0][i] ^ 1) & dp[i - 1];
        }
        for (int i = 1; i < m; i++) {
            int prev = 0;
            for (int j = 0; j < n; j++) {
                if (obstacleGrid[i][j])
                    dp[j] = 0;
                else
                    dp[j] += prev;
                prev = dp[j];
            }
        }
        return dp[n - 1];
    }
};

// Minimum path sum in Grid (DP 10)

// Method-1
class Solution {
public:
    int solve(int i, int j, int m, int n, vector<vector<int>>& grid, vector<vector<int>>& dp) {
        if (i == m - 1 && j == n - 1) {
            return dp[i][j] = grid[i][j];
        }
        if (dp[i][j] != -1) {
            return dp[i][j];
        }
        // Right
        if (i == m - 1) {
            return dp[i][j] = grid[i][j] + solve(i, j + 1, m, n, grid, dp);
        }
        // down
        else if (j == n - 1) {
            return dp[i][j] = grid[i][j] + solve(i + 1, j, m, n, grid, dp);
        }
        return dp[i][j] = grid[i][j] + min(solve(i, j + 1, m, n, grid, dp), solve(i + 1, j, m, n, grid, dp));
    }
    int minPathSum(vector<vector<int>>& grid) {
        int m = grid.size(), n = grid[0].size();
        vector<vector<int>> dp(m, vector<int>(n, -1));
        return solve(0, 0, m, n, grid, dp);
    }
};

// Method-2
class Solution {
public:
    int minPathSum(vector<vector<int>>& grid) {
        int m = grid.size(), n = grid[0].size();
        vector<vector<int>> dp(m, vector<int>(n, 0));        
        // Initialize the first cell of dp table
        dp[0][0] = grid[0][0];
        // Initialize the first column of dp table
        for (int i = 1; i < m; ++i) {
            dp[i][0] = dp[i - 1][0] + grid[i][0];
        }
        // Initialize the first row of dp table
        for (int j = 1; j < n; ++j) {
            dp[0][j] = dp[0][j - 1] + grid[0][j];
        }
        // Fill the rest of the dp table
        for (int i = 1; i < m; ++i) {
            for (int j = 1; j < n; ++j) {
                dp[i][j] = grid[i][j] + min(dp[i - 1][j], dp[i][j - 1]);
            }
        }
        // Return the value in the bottom-right corner of dp table
        return dp[m - 1][n - 1];
    }
};

// Minimum path sum in Triangular Grid (DP 11)

// Method-1
class Solution {
public:
    int solve(vector<vector<int>>& triangle, vector<vector<int>>& memo, int s, int i) {
        if (s == triangle.size() - 1) {
            return triangle[s][i];
        }
        if (memo[s][i] != -1) {
            return memo[s][i];
        }
        int a = triangle[s][i] + solve(triangle, memo, s + 1, i);
        int b = INT_MAX;
        if (i < s + 1) {
            b = triangle[s][i] + solve(triangle, memo, s + 1, i + 1);
        }
        memo[s][i] = min(a, b);
        return memo[s][i];
    }
    int minimumTotal(vector<vector<int>>& triangle) {
        int n = triangle.size();
        vector<vector<int>> memo(n, vector<int>(n, -1));
        return solve(triangle, memo, 0, 0);
    }
};

// Method-2
class Solution {
public:
    int minimumTotal(vector<vector<int>>& triangle) {
        int n = triangle.size();
        vector<vector<int>> dp(n, vector<int>(n, 0));
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < i + 1; j++) {
                dp[i][j] = triangle[i][j];
            }
        }
        for (int i = n - 2; i >= 0; i--) {
            for (int j = 0; j <= i; j++) {
                dp[i][j] = dp[i][j] + min(dp[i + 1][j], dp[i + 1][j + 1]);
            }
        }
        return dp[0][0];
    }
};

// Minimum/Maximum Falling Path Sum (DP-12)

// Method-1
class Solution {
public:
    int minFallingPathSum(vector<vector<int>>& matrix) {
        int n = matrix.size();
        int m = matrix[0].size();
        vector<int> prev(m, 0), cur(m, 0);
        for (int j = 0; j < m; j++) {
            prev[j] = matrix[0][j];
        }
        for (int i = 1; i < n; i++) {
            for (int j = 0; j < m; j++) {
                int up = matrix[i][j] + prev[j];
                int leftDiagonal = matrix[i][j];
                if (j - 1 >= 0) leftDiagonal += prev[j - 1];
                else leftDiagonal += 1e9;
                int rightDiagonal = matrix[i][j];
                if (j + 1 < m) rightDiagonal += prev[j + 1];
                else rightDiagonal += 1e9;
                cur[j] = min(up, min(leftDiagonal, rightDiagonal));
            }
            prev = cur;
        }
        int mini = INT_MAX;
        for (int j = 0; j < m; j++) {
            mini = min(mini, prev[j]);
        }
        return mini;
    }
};

// Method-2
class Solution {
public:
    int minFallingPathSum(vector<vector<int>>& matrix) {
        int n = matrix.size();
        int m = matrix[0].size();
        vector<int> prev(m, 0), cur(m, 0);
        for (int j = 0; j < m; j++) {
            prev[j] = matrix[0][j];
        }
        for (int i = 1; i < n; i++) {
            for (int j = 0; j < m; j++) {
                int up = matrix[i][j] + prev[j];
                int leftDiagonal = matrix[i][j];
                if (j - 1 >= 0) {
                    leftDiagonal += prev[j - 1];
                }
                else {
                    leftDiagonal += 1e9;
                }
                int rightDiagonal = matrix[i][j];
                if (j + 1 < m) {
                    rightDiagonal += prev[j + 1];
                }
                else {
                    rightDiagonal += 1e9;
                }
                cur[j] = min(up, min(leftDiagonal, rightDiagonal));
            }
            prev = cur;
        }
        int mini = INT_MAX;
        for (int j = 0; j < m; j++) {
            mini = min(mini, prev[j]);
        }
        return mini;
    }
};

// 3-d DP : Ninja and his friends (DP-13)

// Method-1
class Solution{
    public:
    int f(int i, int j1, int j2, int n, int m, vector<vector<int>>& grid, vector<vector<vector<int>>>& dp) {
        if (j1 < 0 || j2 < 0 || j1 >= m || j2 >= m) return -1e8;
        if (i == n - 1) {
            if (j1 == j2) return grid[i][j1];
            else return grid[i][j1] + grid[i][j2];
        }
        if (dp[i][j1][j2] != -1) return dp[i][j1][j2];
        int maxi = -1e8;
        for (int dj1 = -1; dj1 <= 1; dj1++) {
            for (int dj2 = -1; dj2 <= 1; dj2++) {
                int value = 0;
                if (j1 == j2) value = grid[i][j1];
                else value = grid[i][j1] + grid[i][j2];
                value += f(i + 1, j1 + dj1, j2 + dj2, n, m, grid, dp);
                maxi = max(maxi, value);
            }
        }
        return dp[i][j1][j2] = maxi;
    }
    
    int solve(int n, int m, vector<vector<int>>& grid) {
        vector<vector<vector<int>>> dp(n, vector<vector<int>>(m, vector<int>(m, -1)));
        return f(0, 0, m - 1, n, m, grid, dp);
    }
};

// Method-2
class Solution{
    public:
    int solve(int n, int m, vector<vector<int>>& grid) {
        vector<vector<vector<int>>> dp(n, vector<vector<int>>(m, vector<int>(m, -1e8)));
    
        // Base case initialization
        for (int j1 = 0; j1 < m; ++j1) {
            for (int j2 = 0; j2 < m; ++j2) {
                if (j1 == j2) {
                    dp[n - 1][j1][j2] = grid[n - 1][j1];
                } else {
                    dp[n - 1][j1][j2] = grid[n - 1][j1] + grid[n - 1][j2];
                }
            }
        }
    
        // Filling the DP table
        for (int i = n - 2; i >= 0; --i) {
            for (int j1 = 0; j1 < m; ++j1) {
                for (int j2 = 0; j2 < m; ++j2) {
                    int maxi = -1e8;
                    for (int dj1 = -1; dj1 <= 1; ++dj1) {
                        for (int dj2 = -1; dj2 <= 1; ++dj2) {
                            int new_j1 = j1 + dj1;
                            int new_j2 = j2 + dj2;
                            if (new_j1 >= 0 && new_j1 < m && new_j2 >= 0 && new_j2 < m) {
                                int value = 0;
                                if (j1 == j2) {
                                    value = grid[i][j1];
                                } else {
                                    value = grid[i][j1] + grid[i][j2];
                                }
                                value += dp[i + 1][new_j1][new_j2];
                                maxi = max(maxi, value);
                            }
                        }
                    }
                    dp[i][j1][j2] = maxi;
                }
            }
        }
    
        return dp[0][0][m - 1];
    }
};

/* 4: DP on Subsequences */

// Subset sum equal to target (DP- 14)

// Method-1
class Solution{   
public:
    int count(int ind,vector<int>arr,int sum,vector<int> &dp)
    {
        if(ind==0) return arr[ind]==sum;
        if(sum<0) return 0;
        if(sum==0) return 1;
        if(dp[sum]!=-1) return dp[sum];
        return dp[sum]=count(ind-1,arr,sum-arr[ind],dp)||count(ind-1,arr,sum,dp);
    }
    bool isSubsetSum(vector<int>arr, int sum){
        vector<int>dp(sum+1,-1);
        int n=arr.size();
        return count(n-1,arr,sum,dp);
    }
};

// Method-2
class Solution{   
public:
    bool isSubsetSum(vector<int>arr, int sum){
        int n=arr.size();
        vector<vector<bool>> t(n+1,vector<bool>(sum+1,false));
        for(int i=0;i<n+1;i++){
            t[i][0]=true;
        }
        for(int i=1;i<n+1;i++){
            for(int j=1;j<sum+1;j++){
                if(arr[i-1]<=j){
                    t[i][j] = t[i-1][j-arr[i-1]] || t[i-1][j];
                }
                else{
                    t[i][j] = t[i-1][j];
                }
            }
        }
        return t[n][sum];
    }
};

// Partition Equal Subset Sum (DP- 15)

// Method-1
class Solution {
public:
    int dp[201][20001];
    bool solve(vector<int> &nums, int n, int sum)
    {
        if (n <= 0 || sum <= 0)
            return sum == 0;
        if (dp[n][sum] != -1)
            return dp[n][sum];   
        if (nums[n-1] > sum)
            return dp[n][sum] = solve(nums, n-1, sum);
        else
            return dp[n][sum] = solve(nums, n-1, sum) || solve(nums, n-1, sum-nums[n-1]);
    }
    bool canPartition(vector<int>& nums) 
    {
        int sum = 0;
        memset(dp, -1, sizeof(dp));
        for(int i = 0; i < nums.size(); i++)
            sum += nums[i];
        if (sum % 2 != 0) 
            return false;
        return solve(nums, nums.size(), sum/2);
    }
};

// Method-2
class Solution {
public:
    int subsetSum(vector<int> arr, int n, int total)
    {
        int t[n+1][total+1];
        for(int i = 0; i < n+1; i++)
        {
            for(int j = 0; j < total+1; j++)
            {
                if(i == 0)
                    t[i][j] = false;
                if(j == 0)
                    t[i][j] = true;
            }
        }   
        for(int i = 1; i < n+1; i++)
        {
            for(int j = 1; j < total+1; j++)
            {
                if(arr[i-1] <= j)
                    t[i][j] = t[i-1][j - arr[i-1]] || t[i-1][j];
                else
                    t[i][j] = t[i-1][j];
            }
        }
        return t[n][total];
    }
    bool canPartition(vector<int>& nums) 
    {    
        int sum = 0;
        for(int i = 0; i < nums.size(); i++)
            sum += nums[i];
        if(sum % 2 != 0)
            return false;
        return subsetSum(nums, nums.size(), sum/2);  
    }
};

// Partition Set Into 2 Subsets With Min Absolute Sum Diff (DP- 16)

class Solution {
public:
    void subset(int idx, vector<vector<int>>& ans, int siz, int sum,
                vector<int>& nums) {
        if (idx >= nums.size()) {
            if (siz > 0)
                ans[siz].push_back(sum);
            return;
        }
        subset(idx + 1, ans, siz + 1, sum + nums[idx], nums);
        subset(idx + 1, ans, siz, sum, nums);
    }
    int minimumDifference(vector<int>& nums) {
        int n = nums.size() / 2;
        vector<vector<int>> left(n + 1), right(n + 1);
        vector<int> v1, v2;
        for (int i = 0; i < n; i++)
            v1.push_back(nums[i]);
        for (int i = n; i < 2 * n; i++)
            v2.push_back(nums[i]);

        subset(0, left, 0, 0, v1);
        subset(0, right, 0, 0, v2);

        for (int i = 0; i < right.size(); i++) {
            sort(right[i].begin(), right[i].end());
        }
        int ans = 1e9;
        int sum = 0;
        for (auto& i : nums)
            sum += i;
        ans = min(abs(sum - 2 * left[n][0]), abs(sum - 2 * right[n][0]));
        for (int i = 1; i <= n; i++) {
            int rsiz = n - i;
            vector<int> tmp = right[rsiz];
            for (auto& j : left[i]) {
                int b = (sum - 2 * j) / 2;
                auto it = lower_bound(tmp.begin(), tmp.end(), b);
                if (it != tmp.end()) {
                    ans = min(ans, abs(sum - 2 * (j + (*it))));
                }
                if (it != tmp.begin()) {
                    it--;
                    ans = min(ans, abs(sum - 2 * (j + (*it))));
                }
            }
        }
        return ans;
    }
};

// Count Subsets with Sum K (DP - 17)

// Method-1
class Solution{
public:
    int mod = 1e9 + 7;
    int f(int ind, int sum, int arr[], vector<vector<int>> &dp){
        if(ind==0){
            if(sum==0 && arr[0]==0) return 2;
            if(arr[0]==sum || sum==0) return 1;
            return 0;
        }
        if(dp[ind][sum] != -1) return dp[ind][sum];
        int notPick = f(ind-1,sum,arr,dp);
        int pick = 0;
        if(sum >= arr[ind]){
            pick = f(ind-1,sum-arr[ind],arr,dp);
        }
        return dp[ind][sum] = (pick + notPick)%mod;
    }
    int perfectSum(int arr[], int n, int sum){
        vector<vector<int>> v(n,vector<int>(sum+1,-1));
        return f(n-1,sum,arr,v);
    }
};

// Method-2
class Solution{
public:
    int MOD = 1e9 + 7;
    int perfectSum(int arr[], int n, int k){
        vector<vector<int>> dp(n + 1, vector<int>(k + 1, 0));
        // when no element is selecte then sum is always = 0  
        dp[0][0] = 1;
        for (int i = 1; i <= n; i++) {
            for (int j = 0; j <= k; j++) {
                dp[i][j] = dp[i - 1][j];
                if (j >= arr[i - 1]) {
                    dp[i][j] = (dp[i][j] + dp[i - 1][j - arr[i - 1]]) % MOD;
                }
            }
        }
        return dp[n][k];
    }
};

// Method-3
class Solution{
public:
    int perfectSum(int arr[], int n, int sum){
        vector<int>prev(sum+1, 0), cur(sum+1, 0); 
        for(int i=0; i<n; i++){
            cur[0]=1;
        }
        prev[0]=1;
        for(int i=1; i<=n; i++){
            for(int j=0; j<=sum; j++){
                int notpick = prev[j];
                int pick=0;
                if(arr[i-1]<=j)
                pick=prev[j-arr[i-1]];
                cur[j] = (pick+notpick)%mod;
            }
            prev = cur;
        }
        return prev[sum];
    }
};

// Count Partitions with Given Difference (DP - 18)

// Method-1
class Solution {
 public:
    const int MOD = 1e9 + 7; 
    int countSubset(vector<int>& arr, int n, int sum) {
        vector<vector<int>> dp(n + 1, vector<int>(sum + 1, 0));
        for (int i = 0; i <= n; i++) {
            dp[i][0] = 1;  
        }
        for (int i = 1; i <= n; i++) {
            for (int j = 0; j <= sum; j++) {
                if (arr[i - 1] <= j) {
                    dp[i][j] = (dp[i - 1][j - arr[i - 1]] + dp[i - 1][j]) % MOD;
                } 
                else {
                    dp[i][j] = dp[i - 1][j];
                }
            }
        }
        return dp[n][sum];
    }
    int countPartitions(int n, int d, vector<int>& arr) {
        int sum = 0;
        for (int i = 0; i < n; i++) {
            sum += arr[i];
        }   
        if ((sum + d) % 2 != 0) {
            return 0;
        }
        int target = (sum + d) / 2;
        return countSubset(arr, n, target);
    }
};

// Method-2
class Solution {
 public:
    int mod = 1e9+7;
    int countPartitions(int n, int d, vector<int>& arr) {
        int sum = 0;
        for(int i=0;i<n;i++){
            sum+=arr[i];
        }
        if (sum < d || (sum - d) % 2) {
            return 0;
        }
        int k = (sum-d)/2;
        vector<int> dp(k+1,0);
        dp[0]=1;
        for(int i=0;i<n;i++){
            for(int j=k;j>=0;j--){
                if(j-arr[i]>=0 && dp[j-arr[i]]){
                    dp[j] = (dp[j]+dp[j-arr[i]])%mod;
                }
            }
        }
        return dp[k];
    }
};

// 0/1 Knapsack (DP - 19)

// Method-1
class Solution{
    public:
    int find(int w, int wt[], int val[], int indx,vector<vector<int>>&memo){
        if(indx==0){
            if(w>=wt[0])return val[indx];
            return 0;
        }
        if(memo[indx][w]!=-1)
        {
            return memo[indx][w];
        }
        int take=0;
        if(wt[indx]<=w){
            take=val[indx]+find(w-wt[indx],wt,val,indx-1,memo);
        }
        int notake=find(w,wt,val,indx-1,memo);
        memo[indx][w] =max(take,notake);
        return memo[indx][w];
    }
    int knapSack(int W, int wt[], int val[], int n){
       vector<vector<int>>memo(n,vector<int>(W+1,-1));
       return find(W,wt,val,n-1,memo);
    }
};

// Method-2

class Solution
{
    public:
    int knapSack(int W, int wt[], int val[], int n) 
    { 
        vector<vector<int>> dp(n+1,vector<int>(W+1,0));
        for(int i = 1;i<=n;i++){
            for(int j = 1;j<=W;j++){
                if(wt[i-1]<=j){
                    dp[i][j] = max(val[i-1]+dp[i-1][j-wt[i-1]],dp[i-1][j]);
                }
                else{
                    dp[i][j] = dp[i-1][j];
                }
            }
        }
       return dp[n][W];
    }
};

// Minimum Coins (DP - 20)

// Method-1
class Solution {
public:
    int dp[12 + 1][10000 + 1];

    int findLowestCoins(vector<int>& coins, int cur, int amount) {
        if (cur == coins.size() || amount <= 0)
            return (amount == 0) ? 0 : INT_MAX - 1;

        if (dp[cur][amount] != -1)
            return dp[cur][amount];

        int res = -1;
        if (coins[cur] > amount) {
            int doNotTakeCoin = 0 + findLowestCoins(coins, cur + 1, amount - 0);
            dp[cur][amount] = res = doNotTakeCoin;
        } else {
            int takeCoin =
                1 + findLowestCoins(coins, cur + 0, amount - coins[cur]);
            int doNotTakeCoin = 0 + findLowestCoins(coins, cur + 1, amount - 0);
            dp[cur][amount] = res = min(takeCoin, doNotTakeCoin);
        }
        return dp[cur][amount] = res;
    }

    int coinChange(vector<int>& coins, int amount) {
        memset(dp, -1, sizeof(dp));
        int res = findLowestCoins(coins, 0, amount);
        return (res == INT_MAX - 1) ? -1 : res;
    }
};

// Method-2
class Solution {
public:
    int coinChange(vector<int>& coins, int amount) {
        if (amount == 0)
            return 0;
        int n = coins.size();
        vector<int> dp(amount + 1);
        dp[0] = 0;
        for (int i = 1; i <= amount; i++) {
            dp[i] = INT_MAX - 1;
        }
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= amount; j++) {
                if (j >= coins[i - 1])
                    dp[j] = min(1 + dp[j - coins[i - 1]], dp[j]);
                else
                    dp[j] = dp[j];
            }
        }
        int res = dp[amount];
        if (res == INT_MAX - 1)
            return -1;
        else
            return res;
    }
};

// Method-3
class Solution {
public:
    int coinChange(vector<int>& coins, int amount) {
        int n = coins.size();
        // vector<vector<int>>dp(n,vector<int>(amount+1,0));
        vector<int> prev(amount + 1, 0), curr(amount + 1, 0);
        for (int i = 0; i <= amount; i++) {
            if (i % coins[0] == 0)
                prev[i] = i / coins[0];
            else
                prev[i] = 1e9;
        }
        for (int i = 1; i < n; i++) {
            for (int t = 0; t <= amount; t++) {
                int nottake = 0 + prev[t];
                int take = 1e9;
                if (coins[i] <= t) {
                    take = 1 + curr[t - coins[i]];
                }
                curr[t] = min(take, nottake);
            }
            prev = curr;
        }
        if (prev[amount] >= 1e9)
            return -1;
        return prev[amount];
    }
};

// Target Sum (DP - 21)

// Method-1
class Solution {
public:
    int f(int index, int target, vector<int>& nums, vector<vector<int>>& dp) {
        if (index == 0) {
            if (target == 0 && nums[index] == 0)
                return 2;
            if (nums[index] == target || target == 0)
                return 1;
            return 0;
        }
        if (dp[index][target] != -1)
            return dp[index][target];
        int Pick = 0;
        if (nums[index] <= target)
            Pick = f(index - 1, target - nums[index], nums, dp);
        int notPick = f(index - 1, target, nums, dp);
        return dp[index][target] = Pick + notPick;
    }
    int findTargetSumWays(vector<int>& nums, int target) {
        int sum = accumulate(nums.begin(), nums.end(), 0);
        int k = (sum - target);
        if (k < 0 || k % 2 != 0) {
            return 0;
        }
        int n = nums.size();
        vector<vector<int>> dp(n, vector<int>(k + 1, -1));
        return f(n - 1, k / 2, nums, dp);
    }
};

// Method-2
class Solution {
public:
    int findTargetSumWays(vector<int>& nums, int target) {
        int sum = accumulate(nums.begin(), nums.end(), 0);
        int k = (sum - target);
        if (k < 0 || k % 2 != 0) {
            return 0;
        }
        k = k / 2;
        int n = nums.size();
        vector<int> prev(k + 1, 0), curr(k + 1, 0);
        if (nums[0] == 0)
            prev[0] = 2;
        else
            prev[0] = 1;
        if (nums[0] != 0 && nums[0] <= k)
            prev[nums[0]] = 1;
        for (int index = 1; index < n; index++) {
            for (int target = 0; target <= k; target++) {
                int Pick = 0;
                if (nums[index] <= target)
                    Pick = prev[target - nums[index]];
                int notPick = prev[target];
                curr[target] = Pick + notPick;
            }
            prev = curr;
        }
        return prev[k];
    }
};

// Coin Change 2 (DP - 22)

// Method-1
class Solution {
    int solve(int index, vector<int>& coins, int amount,
              vector<vector<int>>& dp) {
        if (index == 0) {
            if (amount % coins[0] == 0)
                return 1;
            else
                return 0;
        }
        if (dp[index][amount] != -1)
            return dp[index][amount];
        int nottake = solve(index - 1, coins, amount, dp);
        int take = 0;
        if (coins[index] <= amount) {
            take = solve(index, coins, amount - coins[index], dp);
        }
        return dp[index][amount] = nottake + take;
    }

public:
    int change(int amount, vector<int>& coins) {
        int n = coins.size();
        vector<vector<int>> dp(n, vector<int>(amount + 1, -1));
        return solve(n - 1, coins, amount, dp);
    }
};

// Method-2
class Solution {
public:
    int change(int amount, vector<int>& coins) {
        int n = coins.size();
        vector<vector<int>> dp(n, vector<int>(amount + 1, 0));
        for (int i = 0; i <= amount; i++) {
            if (i % coins[0] == 0)
                dp[0][i] = 1;
        }
        for (int i = 1; i < n; i++) {
            for (int am = 0; am <= amount; am++) {
                int nottake = dp[i - 1][am];
                int take = 0;
                if (coins[i] <= am) {
                    take = dp[i][am - coins[i]];
                }
                dp[i][am] = take + nottake;
            }
        }
        return dp[n - 1][amount];
    }
};

// Method-3
class Solution {
public:
    int change(int amount, vector<int>& coins) {
        int n = coins.size();
        // vector<vector<int>>dp(n,vector<int>(amount+1,0));
        vector<int> prev(amount + 1, 0), curr(amount + 1, 0);
        for (int i = 0; i <= amount; i++) {
            if (i % coins[0] == 0)
                prev[i] = 1;
        }
        for (int i = 1; i < n; i++) {
            for (int am = 0; am <= amount; am++) {
                int nottake = prev[am];
                int take = 0;
                if (coins[i] <= am) {
                    take = curr[am - coins[i]];
                }
                curr[am] = take + nottake;
            }
            prev = curr;
        }
        return prev[amount];
    }
};

// Unbounded Knapsack (DP - 23)

// Method-1
class Solution{
public:
    int solve(int ind,int W, int wt[], int val[], vector<vector<int>>& dp) {
        if(ind==0) {
            return ((int)W/wt[0])*val[0];
        }
        if(dp[ind][W]!=-1) return dp[ind][W];
        int notTake = solve(ind-1,W,wt,val,dp);
        int take = -1e9;
        if(wt[ind]<=W) {
            take = val[ind] + solve(ind,W-wt[ind],wt,val,dp);
        }
        return dp[ind][W] = max(take,notTake);
    }
    int knapSack(int N, int W, int val[], int wt[]){
        vector<vector<int>>dp(N,vector<int>(W+1,-1));
        return solve(N-1,W,wt,val,dp);
    }
};

// Method-2
class Solution{
public:
    int knapSack(int n, int w, int val[], int wt[]){
        int t[n+1][w+1];
        for(int i = 0 ; i < n+1 ; i++){
            for(int j = 0 ; j < w+1 ; j++){
                if(i == 0 || j == 0){
                    t[i][j] = 0;
                }
            }
        }
        for(int i = 1 ; i < n+1 ; i++){
            for(int j = 1 ; j < w+1 ; j++){
                if(wt[i-1] <= j){
                    t[i][j] = max(val[i-1] + t[i][j - wt[i-1]] , t[i-1][j]);
                }
                else{
                    t[i][j] = t[i-1][j];
                }
            }
        }
        return t[n][w];
    }
};

// Rod Cutting Problem | (DP - 24)

// Method-1
class Solution{
    int t[1002][1002];
public:
    int helper(int price[], int length[], int n, int i){
        if(n == 0 || i == 0) return 0; //Base case is there is no rod or there is not price then profit will be 0
        if(t[n][i] != -1) return t[n][i]; //Checking our cache for sub-problem
        if(length[n-1] <= i){
            //We can cut in current size or we cant cut in current size, Multiple sizes are allowed
            return t[n][i] = max(price[n-1]+helper(price, length, n, i-length[n-1]), helper(price, length, n-1, i));
        }
        //we cant cut in current size coz we dont hv enough size of rod
        else return t[n][i] = helper(price, length, n-1, i);
    }
    int cutRod(int price[], int n) {
        memset(t, -1, sizeof(t));
        //Creating a length array for simplicity of our approach
        int length[n];
        for(int i=0;i<n;i++) length[i] = i+1;
        return helper(price, length, n, n);
    }
};

// Method-2
class Solution{
  public:
    int cutRod(int price[], int n) {
        int len[n];
        for(int i=0;i<n;i++) len[i] = i + 1;
        
        int t[n+1][n+1];
        
        for(int i=0;i<n+1;i++){
            t[i][0] = 0;
            t[0][i] = 0;
        }
        
        for(int i=1;i<n+1;i++){
            for(int j=1;j<n+1;j++){
                if(len[i-1] <= j){
                    t[i][j] = max(price[i-1]+t[i][j-len[i-1]], t[i-1][j]);
                }
                else{
                    t[i][j] = t[i-1][j];
                }
            }
        }
        return t[n][n];
    }
};

// Method-3
class Solution{
  public:
    int cutRod(int price[], int n) {
        vector<int> dp(n+1, 0);
        for(int i = 1; i<=n; i++)
            for(int idx = 0; idx<i; idx++)
                dp[i] = max(dp[i], dp[idx] + price[i-idx-1]);
        return dp[n];
    }
};

/* 5: DP on Strings */

// Longest Common Subsequence | (DP - 25)

// Method-1
class Solution {
public:
    int helper(string text1, string text2, int m, int n, vector<vector<int>>&dp){
        if(m==0 || n==0) return 0;
        else if(dp[m-1][n-1]!=-1) return dp[m-1][n-1];
        else if(text1[m-1]==text2[n-1])
                return dp[m-1][n-1]=1+helper(text1, text2, m-1, n-1, dp);
        else return dp[m-1][n-1]=max(helper(text1, text2, m, n-1, dp), helper(text1, text2, m-1, n, dp));     
    }
    int longestCommonSubsequence(string text1, string text2) {
        int m= text1.size();
        int n=text2.size();
        vector<vector<int>>dp(m, vector<int>(n, -1));
        return helper(text1, text2, m, n, dp);
    }
};

// Method-2
class Solution {
public:
    int longestCommonSubsequence(string text1, string text2) {
        int m= text1.size();
        int n=text2.size();
        vector<vector<int>>dp(m+1, vector<int>(n+1));
        for(int i=0;i<=n;i++){
            dp[0][i]=0;
        }
        for(int i=0;i<=m;i++){
            dp[i][0]=0;
        }
        for(int i=1;i<=m;i++){
            for(int j=1;j<=n;j++){
                if(text1[i-1]==text2[j-1]){
                    dp[i][j]=1+dp[i-1][j-1];
                }
                else{
                    dp[i][j]=max(dp[i][j-1], dp[i-1][j]);
                }
            }
        }
        return dp[m][n];
    }
};

// Method-3
class Solution {
public:
     int longestCommonSubsequence(string text1, string text2) {
         int m= text1.size();
         int n=text2.size();
         vector<int>prev(n+1, 0);
         vector<int>curr(n+1, 0);
         for(int i=1;i<=m;i++){
             for(int j=1;j<=n;j++){
                 if(text1[i-1]==text2[j-1]){
                     curr[j]=1+prev[j-1];
                 }
                 else{
                     curr[j]=max(curr[j-1], prev[j]);
                 }
             }
             prev=curr;
         }
         return prev[n];
     }
};

// Method-4
class Solution {
public:
    int longestCommonSubsequence(string text1, string text2) {
        int m= text1.size();
        int n=text2.size();
        vector<int>prev(n+1, 0);
        int temp=0, diag=0;
        for(int i=1;i<=m;i++){
            diag=0;
            for(int j=1;j<=n;j++){
                temp=prev[j];
                if(text1[i-1]==text2[j-1]){
                    prev[j]=1+diag;
                }
                else{
                    prev[j]=max(prev[j], prev[j-1]);
                }
                diag=temp;
            }
        }
        return prev[n];
    }
};

// Print Longest Common Subsequence | (DP - 26)

class Solution{
	int dp[101][101];
	int lcs_len = 0;
	vector<string> res;
	private:
		int lcs(string s, string t, int pos1, int pos2){
			// base condition 
			if(pos1 == s.size() or pos2 == t.size())
				return 0;
			int &ans  = dp[pos1][pos2];
			// if lcs has been computed
			if(ans != -1)
				return ans;
			// if characters are same return previous + 1 else 
			// max of two sequences after removing i'th and j'th 
			// char one by one 
			if(s[pos1] == t[pos2])
				return ans = 1 + lcs(s, t, pos1 + 1, pos2 + 1);
			return ans = max(lcs(s, t, pos1 + 1, pos2), lcs(s, t, pos1, pos2 + 1));
		}
	private:
		void helper(string s, string t, string cur, int pos1, int pos2, int cur_lcs){
			// if currlcs is equal to lcslen then store it 
			if(cur_lcs == lcs_len){
				res.push_back(cur);
				return ;
			}
			// if we are done with all the characters of both string 
			if(pos1 == s.size() or pos2 == t.size())
				return ;
		    // here we have to print all sub-sequences lexicographically, 
    		// that's why we start from 'a'to'z' if this character is 
    		// present in both of them then append it in cur and same 
    		// remaining part 
			for(char ch = 'a'; ch <= 'z'; ch++){
				// f is a flag to tell that we have printed all the subsequences corresponding to current character
				bool f = false;
				for(int i = pos1; i < s.size(); i++){
					if(s[i] == ch){
						for(int j = pos2; j < t.size(); j++){
		                // if ch is present in both of them and remaining length is equal to remaining lcs length then add ch in sub-sequenece 
							if(t[j] == ch and lcs(s, t, i, j) == lcs_len - cur_lcs){
								string new_cur = cur + ch;
								helper(s, t, new_cur, i + 1, j + 1, cur_lcs + 1);
								f = true;
								break;
							}
						}
					}
					// If we found LCS beginning with current character
					if(f)
						break;
				}
			}
		}
	public:
		vector<string> all_longest_common_subsequences(string s, string t){
			memset(dp, -1, sizeof(dp));
			lcs_len = lcs(s, t, 0, 0);
			helper(s, t, "", 0, 0, 0);
			return res;
		}
};

// Longest Common Substring | (DP - 27)

// Method-1

class Solution{
    public:
    int longestCommonSubstr (string S1, string S2, int n, int m)
    {
        int count=0;
        int i=0;
        int j=0;
        string temp;
        int ans=0;
        while(i<m && j<m)
        {
            temp+=S2[j];
            if(S1.find(temp)!= string::npos)
            {
                count++;
                ans=max(count,ans);
                j++;
            }
            else
            {
                count=0;
                i++;
                j=i;
                temp="";
            }
            
        }
        return ans;
    }
};

// Method-2

class Solution{
    public:
     int longestCommonSubstr (string S1, string S2, int n, int m)
    {
       int dp[n+1][m+1];
       int ans=0;
       for(int i=0;i<n+1;i++)
       {
           for(int j=0;j<m+1;j++)
           {
               if(i==0 || j==0)
               dp[i][j]=0;
           }
       }
       for(int i=1;i<n+1;i++)
       {
           for(int j=1;j<m+1;j++)
           {
               if(S1[i-1] == S2[j-1])
               {
                   dp[i][j]=1+dp[i-1][j-1];
                   ans=max(ans,dp[i][j]);
               }
               else
               dp[i][j]=0;
           }
       }
       return ans;
    }
};

// Longest Palindromic Subsequence | (DP-28)

// Method-1
class Solution {
public:
    int solve(string& s, vector<vector<int>>&dp, int start, int end)
    {
        if (start == end) return 1;
        if (start > end) return 0;
        if (dp[start][end] != -1) return dp[start][end];
        
        if (s[start] == s[end]) return (2 + solve(s, dp, start + 1, end - 1)); //directly return 
        
        int leaveLeft = solve(s, dp, start + 1, end);
        int leaveRight = solve(s, dp, start, end - 1);
        return dp[start][end] = max(leaveLeft, leaveRight); //store the ans
    }
    int longestPalindromeSubseq(string s) 
    {
        int n = s.size();
        vector<vector<int>>dp(n, vector<int>(n, -1));
        int ans = solve(s, dp, 0, n - 1);
        return ans;
    }
};

// Method-2
class Solution {
public:
    int longestPalindromeSubseq(string s) {
        int n = s.size();
        vector<vector<int>>dp(n, vector<int>(n, 0));
        // for n length string we need LPS for string with length (n - 1) or (n - 2)
        // We need to already have LPS for smaller lengths before moving to greater lengths
        // so we need to go bottom up 
        // Calculating LPS for all strings of length = 1 to length = n
        for (int len = 1; len <= n; len++){
            for (int start = 0; start <= (n - len); start++){
                int end = start + len - 1; // [start, end] denotes the string under consideration
                if (len == 1) { 
                    dp[start][end] = 1; continue; 
                }
                if (s[start] == s[end]) 
                    dp[start][end] = 2 + dp[start + 1][end - 1];
                else 
                    dp[start][end] = max(dp[start + 1][end], dp[start][end - 1]); 
            }
        }
        return dp[0][n - 1];
    }
};

// Minimum insertions to make string palindrome | DP-29

// Method-1
class Solution {
private:
    int solveMemoization(string& s, string& t, int p1, int p2, vector<vector<int>>& dp) {
        if (p1 < 0 || p2 < 0)
            return 0;
        if (dp[p1][p2] != -1)
            return dp[p1][p2];
        int ans = 0;
        if (s[p1] == t[p2])
            ans = 1 + solveMemoization(s, t, p1 - 1, p2 - 1, dp);
        else
            ans = max(solveMemoization(s, t, p1 - 1, p2, dp), solveMemoization(s, t, p1, p2 - 1, dp));
        dp[p1][p2] = ans;
        return dp[p1][p2];
    }

public:
    int minInsertions(string s) {
        int n = s.size();
        string t = s;
        reverse(t.begin(), t.end());
        vector<vector<int>> dp(n + 1, vector<int>(n + 1, -1));
        int longestPalindrome = solveMemoization(s, t, n - 1, n - 1, dp);
        return n - longestPalindrome;
    }
};

// Method-2
class Solution {
public:
    int minInsertions(string s) {
        int n = s.length();
        vector<int> dp(n, 0);
        for (int i = n - 2; i >= 0; i--) {
            int prev = 0;
            for (int j = i + 1; j < n; j++) {
                int temp = dp[j];
                if (s[i] == s[j]) {
                    dp[j] = prev;
                } else {
                    dp[j] = min(dp[j], dp[j-1]) + 1;
                }
                prev = temp;
            }
        }
        return dp[n-1];        
    }
};

// Method-3
class Solution {
public:
    int minInsertions(string s) {
        // n-len(l c palindromic subseq).
        int n = s.size();
        string s1 = s;
        reverse(s.begin(), s.end());
        string s2 = s;
        vector<int> prev(n + 1, 0), curr(n + 1, 0);
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= n; j++) {
                if (s1[i - 1] == s2[j - 1]) {
                    curr[j] = prev[j - 1] + 1;
                } else {
                    curr[j] = max(curr[j - 1], prev[j]);
                }
            }
            prev = curr;
        }
        int palin = prev[n];
        int ans = n - palin;
        return ans;
    }
};

// Minimum Insertions/Deletions to Convert String | (DP- 30)

class Solution {
public:
    int lcs(string s1, string s2) {
        int m = s1.length();
        int n = s2.length();
        int dp[m + 1][n + 1];
        for (int i = 0; i <= m; i++) {
            for (int j = 0; j <= n; j++) {
                if (i == 0 || j == 0){
                    dp[i][j] = 0;
                } else if (s1[i - 1] == s2[j - 1]) {
                    dp[i][j] = 1 + dp[i - 1][j - 1];
                } else {
                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);
                }
            }
        }
        return dp[m][n];
    }
    int minDistance(string word1, string word2) {
        int a = lcs(word1, word2);
        int m = word1.size(), n = word2.size();
        int dels = (m - a) + (n - a);
        return dels;
    }
};

// Shortest Common Supersequence | (DP - 31)

// Method-1
class Solution {
public:
    int dp[1001][1001];
    int solve(string& a, string& b, int n, int m) {
        if (n == 0 || m == 0) {
            return 0;
        }
        if (dp[n][m] != -1) {
            return dp[n][m];
        }
        if (a[n - 1] == b[m - 1]) {
            return dp[n][m] = 1 + solve(a, b, n - 1, m - 1);
        }
        return dp[n][m] = max(solve(a, b, n - 1, m), solve(a, b, n, m - 1));
    }
    string shortestCommonSupersequence(string a, string b) {
        memset(dp, -1, sizeof(dp));
        int n = a.length();
        int m = b.length();
        int size = solve(a, b, n, m);
        string ans = "";
        int i = n, j = m;
        while (i > 0 && j > 0) {
            if (a[i - 1] == b[j - 1]) {
                ans += a[i - 1];
                i--, j--;
            } else if (dp[i][j - 1] > dp[i - 1][j]) {
                ans += b[j - 1];
                j--;
            } else {
                ans += a[i - 1];
                i--;
            }
        }
        while (i > 0) {
            ans += a[i - 1];
            i--;
        }
        while (j > 0) {
            ans += b[j - 1];
            j--;
        }
        reverse(ans.begin(), ans.end());
        return ans;
    }
};

// Method-2
class Solution {
public:
    string shortestCommonSupersequence(string a, string b) {
        int n = a.length();
        int m = b.length();
        int dp[n + 1][m + 1];
        for (int i = 0; i < n + 1; i++) {
            for (int j = 0; j < m + 1; j++) {
                if (i == 0 || j == 0) {
                    dp[i][j] = 0;
                }
            }
        }
        for (int i = 1; i < n + 1; i++) {
            for (int j = 1; j < m + 1; j++) {
                if (a[i - 1] == b[j - 1]) {
                    dp[i][j] = 1 + dp[i - 1][j - 1];
                } else {
                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);
                }
            }
        }
        string ans = "";
        int i = n, j = m;
        while (i > 0 && j > 0) {
            if (a[i - 1] == b[j - 1]) {
                ans += a[i - 1];
                i--, j--;
            } else {

                if (dp[i][j - 1] > dp[i - 1][j]) {
                    ans += b[j - 1];
                    j--;
                } else {
                    ans += a[i - 1];
                    i--;
                }
            }
        }
        while (i > 0) {
            ans += a[i - 1];
            i--;
        }
        while (j > 0) {
            ans += b[j - 1];
            j--;
        }
        reverse(ans.begin(), ans.end());
        return ans;
    }
};

// Distinct Subsequences| (DP-32)

// Method-1
class Solution {
    int solve(int i, int j, string& s, string& t, vector<vector<int>>& dp) {
        if (j == 0)
            return 1;
        if (i == 0)
            return 0;
        if (dp[i][j] != -1)
            return dp[i][j];
        if (s[i - 1] == t[j - 1]) {
            return dp[i][j] = solve(i - 1, j - 1, s, t, dp) + solve(i - 1, j, s, t, dp);
        }
        return dp[i][j] = solve(i - 1, j, s, t, dp);
    }
public:
    int numDistinct(string s, string t) {
        int n = s.size();
        int m = t.size();
        vector<vector<int>> dp(n + 1, vector<int>(m + 1, -1));
        return solve(n, m, s, t, dp);
    }
};

// Method-2
class Solution {
public:
    int numDistinct(string s, string t) {
        int n = s.size();
        int m = t.size();
        vector<vector<double>> dp(n + 1, vector<double>(m + 1, 0));
        for (int i = 0; i <= n; i++)
            dp[i][0] = 1;
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= m; j++) {
                if (s[i - 1] == t[j - 1]) {
                    dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j];
                } else {
                    dp[i][j] = dp[i - 1][j];
                }
            }
        }
        return (int)dp[n][m];
    }
};

// Method-3
class Solution {
public:
    int numDistinct(string s, string t) {
        int n = s.size();
        int m = t.size();
        vector<double> prev(m + 1, 0);
        prev[0] = 1;
        for (int i = 1; i <= n; i++) {
            for (int j = m; j >= 1; j--) {
                if (s[i - 1] == t[j - 1]) {
                    prev[j] = prev[j - 1] + prev[j];
                }
            }
        }
        return (int)prev[m];
    }
};

// Edit Distance | (DP-33)

// Method-1
class Solution {
public:
    int count(string word1, string word2, int m, int n, vector<vector<int>>&dp){
        if(m==0) return n;
        if(n==0) return m;
        if(dp[m][n]!=-1) return dp[m][n];
        if(word1[m-1]==word2[n-1]) return count(word1, word2, m-1, n-1, dp);
        else{
            //perform operations on word2
            int del= count(word1, word2, m, n-1, dp);
            int insert= count(word1, word2, m-1, n, dp);
            int replace= count(word1, word2, m-1, n-1, dp);
            int res=min(del, insert);
            res=min(res, replace);
            return dp[m][n]= 1+res;
        }
    }
    int minDistance(string word1, string word2) {
        int m=word1.size();
        int n=word2.size();
        vector<vector<int>>dp(m+1, vector<int>(n+1, -1));
        return count(word1, word2, m, n, dp);
    }
};

// Method-2
class Solution {
public:
    int minDistance(string word1, string word2) {
        int m=word1.size();
        int n=word2.size();
        vector<vector<int>>dp(m+1, vector<int>(n+1));
        for(int i=0;i<=n;i++){
            dp[0][i]=i;
        }
        for(int i=0;i<=m;i++){
            dp[i][0]=i;
        }
        for(int i=1;i<=m;i++){
            for(int j=1;j<=n;j++){
                if(word1[i-1]==word2[j-1]) dp[i][j]=dp[i-1][j-1];
                else{
                    dp[i][j]=min(dp[i][j-1], dp[i-1][j]);
                    dp[i][j]=1+min(dp[i][j], dp[i-1][j-1]);
                }
            }
        }
        return dp[m][n];
    }
};

// Method-3
class Solution {
public:
    int minDistance(string word1, string word2) {
        int m=word1.size();
        int n=word2.size();
        vector<int>curr(n+1), prev(n+1);
        for(int i=0;i<=n;i++){
            prev[i]=i;
        }
        for(int i=1;i<=m;i++){
            curr[0]=i;
            for(int j=1;j<=n;j++){
                if(word1[i-1]==word2[j-1]) curr[j]=prev[j-1];
                else{
                    curr[j]=min(curr[j-1], prev[j]);
                    curr[j]=1+min(curr[j], prev[j-1]);
                }
            }
            prev=curr;
        }
        return prev[n];
    }
};


// Wildcard Matching | (DP-34)

// Method-1
class Solution {
public:
    int f(int i,int j, string &s,string &p,vector<vector<int>> &dp){
        if(dp[i][j]!=-1) return dp[i][j];
        if(i==0 && j==0) return dp[i][j]=1;
        if(j==0 && i>0) return dp[i][j]=0;
        if(i==0 && j>0){
            while(j>0){
                if(p[j-1]=='*') j--;
                else return dp[i][j]=0;
            }
            return dp[i][j]=1;
        }
        if(s[i-1]==p[j-1] || p[j-1]=='?') 
            return dp[i][j]=f(i-1,j-1,s,p,dp);
        if(p[j-1]=='*'){
            return dp[i][j] = f(i-1,j,s,p,dp) || f(i,j-1,s,p,dp) ? 1:0;
            //Two cases
            //Consider * as len=0
            //Give one charcter to * and remain at *
            //at next step it will again be decided from both these cases
        }
        return dp[i][j]=0;
        
    }
    bool isMatch(string s, string p) {
        int n=s.length(),m=p.length();
        vector<vector<int>> dp(n+1,vector<int>(m+1,-1));
        return f(n,m,s,p,dp);
    }
};

// Method-2
class Solution {
public:
    bool isMatch(string s, string p) {
        int n=s.length(),m=p.length();
        vector<vector<bool>> dp(n+1,vector<bool>(m+1));
        dp[0][0]=true;
        for(int i=1;i<=n;i++) 
            dp[i][0]=false;
        bool flag=true;
        for(int i=1;i<=m;i++){
            if(p[i-1]!='*')
                flag=false;
            dp[0][i]=flag;
        }
        for(int i=1;i<=n;i++){
            for(int j=1;j<=m;j++){
                if(s[i-1]==p[j-1] || p[j-1]=='?')
                    dp[i][j]=dp[i-1][j-1];
                else if(p[j-1]=='*')
                    dp[i][j] = dp[i-1][j] || dp[i][j-1];
                else dp[i][j]=false;
            }
        }
        return dp[n][m];
    }
};

// Method-3
class Solution {
public:
    bool isMatch(string s, string p) {
        int n=s.length(),m=p.length();
        vector<bool> prev(m+1);
        //Initially prev is for n=0
        prev[0]=true;
        bool flag=true;
        for(int i=1;i<=m;i++){
            if(p[i-1]!='*')
                flag=false;
            prev[i]=flag;
        }
        vector<bool> curr(m+1);
        for(int i=1;i<=n;i++){
            curr[0]=false;
            for(int j=1;j<=m;j++){
                if(s[i-1]==p[j-1] || p[j-1]=='?')
                    curr[j]=prev[j-1];
                else if(p[j-1]=='*')
                    curr[j] = prev[j] || curr[j-1];
                else curr[j]=false;
            }
            prev=curr;
        }
        return prev[m];
    }
};

/* 6: DP on Stocks */

// Best Time to Buy and Sell Stock |(DP-35)

class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int n = prices.size();
        int minimum = prices[0];
        int maximumProfit = 0;
        for (int i = 0; i < n; i++) {
            minimum = min(minimum, prices[i]);
            int profit = prices[i] - minimum;
            maximumProfit = max(maximumProfit, profit);
        }
        return maximumProfit;
    }
};

// Buy and Sell Stock - II|(DP-36)

// Method-1
class Solution {
public:
    int solveMem(vector<int>& prices, int index, int buy, vector<vector<int>>& dp) {
        if (index == prices.size())
            return 0;
        if (dp[index][buy] != -1)
            return dp[index][buy];
        int profit = 0;
        if (buy) {
            int buykaro = (-prices[index]) + solveMem(prices, index + 1, 0, dp);
            int skipkaro = 0 + solveMem(prices, index + 1, 1, dp);
            profit = max(buykaro, skipkaro);
        } else {
            int sellkaro = (prices[index]) + solveMem(prices, index + 1, 1, dp);
            int skipkaro = 0 + solveMem(prices, index + 1, 0, dp);
            profit = max(sellkaro, skipkaro);
        }
        return dp[index][buy] = profit;
    }
    int maxProfit(vector<int>& prices) {
        int n = prices.size();
        vector<vector<int>> dp(n, vector<int>(2, -1));
        return solveMem(prices, 0, 1, dp);
    }
};

// Method-2
class Solution {
public:
    int solveTab(vector<int>& prices) {
        int n = prices.size();
        vector<vector<int>> dp(n + 1, vector<int>(2, 0));
        for (int index = n - 1; index >= 0; index--) {
            for (int buy = 0; buy <= 1; buy++) {
                int profit = 0;
                if (buy) {
                    int buykaro = (-prices[index]) + dp[index + 1][0];
                    int skipkaro = 0 + dp[index + 1][1];
                    profit = max(buykaro, skipkaro);
                } else {
                    int sellkaro = (prices[index]) + dp[index + 1][1];
                    int skipkaro = 0 + dp[index + 1][0];
                    profit = max(sellkaro, skipkaro);
                }
                dp[index][buy] = profit;
            }
        }
        return dp[0][1];
    }
    int maxProfit(vector<int>& prices) { 
        return solveTab(prices);
    }
};

// Method-3
class Solution {
public:
    int solveOpt(vector<int>& prices) {
        int n = prices.size();
        vector<int> curr(2, 0);
        vector<int> next(2, 0);
        for (int index = n - 1; index >= 0; index--) {
            for (int buy = 0; buy <= 1; buy++) {
                int profit = 0;
                if (buy) {
                    int buykaro = (-prices[index]) + next[0];
                    int skipkaro = 0 + next[1];
                    profit = max(buykaro, skipkaro);
                } else {
                    int sellkaro = (prices[index]) + next[1];
                    int skipkaro = 0 + next[0];
                    profit = max(sellkaro, skipkaro);
                }
                curr[buy] = profit;
            }
            next = curr;
        }
        return next[1];
    }
    int maxProfit(vector<int>& prices) { 
        return solveOpt(prices); 
    }
};

// Buy and Sell Stocks III|(DP-37)

// Method-1
class Solution {
public:
    int solveMem(vector<int>& prices, int index, bool buy, int limit, vector<vector<vector<int>>> &dp){
        if(index >= prices.size()) return 0;
        if(dp[index][buy][limit] != -1){
            return dp[index][buy][limit];
        }
        int profit = 0;
        if(buy && limit < 2){
            int choose = -prices[index] + solveMem(prices, index+1, 0, limit+1, dp);
            int skip = 0 + solveMem(prices, index+1, 1, limit, dp);
            profit = max(choose, skip);
        }
        else if(buy == 0){
            int choose = prices[index] + solveMem(prices, index+1, 1, limit, dp);
            int skip = 0 + solveMem(prices, index+1, 0, limit, dp);
            profit = max(choose, skip);
        }
        return dp[index][buy][limit] = profit;
    }
    int maxProfit(vector<int>& prices) {
        int n = prices.size();
        int index = 0;
        bool buy = 1;
        int limit = 0;
        vector<vector<vector<int>>> dp(n, vector<vector<int>>(2, vector<int>(3, -1)));
        return solveMem(prices, index, buy, limit, dp);
    }
};

// Method-2

class Solution {
public:
    int solveTab(vector<int>& prices){
        int n = prices.size();
        vector<vector<vector<int>>> dp(n+1, vector<vector<int>>(2, vector<int>(3, 0)));
        for(int index = n-1; index >= 0; index--){
            for(int buy = 0; buy <= 1; buy++){
                for(int limit = 2; limit >= 0; limit--){
                    int profit = 0;
                    if(buy && limit < 2){
                        int choose = -prices[index] + dp[index+1][0][limit+1];
                        int skip = 0 + dp[index+1][1][limit];
                        profit = max(choose, skip);
                    }
                    else if(buy == 0){
                        int choose = prices[index] + dp[index+1][1][limit];
                        int skip = 0 + dp[index+1][0][limit];
                        profit = max(choose, skip);
                    }
                    dp[index][buy][limit] = profit;
                }
            }
        }
        return dp[0][1][0];
    }
    int maxProfit(vector<int>& prices) {
        int n = prices.size();
        int index = 0;
        bool buy = 1;
        int limit = 0;
        return solveTab(prices);
    }
};

// Method-3
class Solution {
public:
    int solveSO(vector<int> &prices){
        int n = prices.size();
        vector<vector<int>> curr(2, vector<int>(3, 0));
        vector<vector<int>> next(2, vector<int>(3, 0));
        for(int index = n-1; index >= 0; index--){
            for(int buy = 0; buy <= 1; buy++){
                for(int limit = 2; limit >= 0; limit--){
                    int profit = 0;
                    if(buy && limit < 2){
                        int choose = -prices[index] + next[0][limit+1];
                        int skip = 0 + next[1][limit];
                        profit = max(choose, skip);
                    }
                    else if(buy == 0){
                        int choose = prices[index] + next[1][limit];
                        int skip = 0 + next[0][limit];
                        profit = max(choose, skip);
                    }
                    curr[buy][limit] = profit;
                }
            }
            next = curr;
        }
        return curr[1][0];
    }
    int maxProfit(vector<int>& prices) {
        return solveSO(prices);
    }
};

// Buy and Stock Sell IV |(DP-38)

// Method-1
class Solution {
    int dfs(int i, int t, int k, int n, vector<int> & p, vector<vector<int>> &dp) {
        if(i == n || t == 2 * k) return 0;
        if(dp[i][t] != -1) return dp[i][t];

        if(t % 2 == 0) {
            return dp[i][t] = max(-p[i] + dfs(i + 1, t + 1, k, n, p, dp), 0 + dfs(i + 1, t, k, n, p, dp));
        }
        return dp[i][t] = max(p[i] + dfs(i + 1, t + 1, k, n, p, dp), 0 + dfs(i + 1, t, k, n, p, dp));
    }
public:
    int maxProfit(int k, vector<int>& prices) {
        int n = prices.size();
        vector<vector<int>> dp(n, vector<int>(2 * k, -1));
        
        return dfs(0, 0, k, n, prices, dp);
    }
};

// Method-2
class Solution {
public:
    int maxProfit(int k, vector<int>& p) {
        int n = p.size();
        vector<vector<int>> dp(n + 1, vector<int>(2 * k + 1));
        for(int i=n-1; i>=0; i--) {
            for(int t=0; t<2 * k; t++) {
                if(t % 2 == 0) {
                    dp[i][t] = max(-p[i] + dp[i + 1][t + 1], 0 + dp[i + 1][t]);
                }
                else dp[i][t] = max(p[i] + dp[i + 1][t + 1], 0 + dp[i + 1][t]);
            }
        }
        return dp[0][0];
    }
};

// Method-3
class Solution {
public:
    int maxProfit(int k, vector<int>& p) {
        int n = p.size();
        vector<int> dp(2 * k + 1), temp(2 * k + 1);
        for(int i=n-1; i>=0; i--) {
            for(int t=0; t<2 * k; t++) {
                if(t % 2 == 0) {
                    temp[t] = max(-p[i] + dp[t + 1], 0 + dp[t]);
                }
                else temp[t] = max(p[i] + dp[t + 1], 0 + dp[t]);
            }
            dp = temp;
        }
        return dp[0];
    }
};

// Buy and Sell Stocks With Cooldown|(DP-39)

// Method-1
class Solution {
public:
    int solve(int day, int n, int buy, vector<int>& prices, vector<vector<int>>& dp) {
        if (day >= n) {
            return 0;
        }
        if (dp[day][buy] != -1) {
            return dp[day][buy];
        }
        int profit = 0;
        // BUYING
        if (buy) {
            int taken = solve(day + 1, n, 0, prices, dp) - prices[day]; // sell
            int notTaken = solve(day + 1, n, 1, prices, dp); // buy
            profit = max(taken, notTaken);
        }
        // SELLING
        else {
            int sell = prices[day] + solve(day + 2, n, 1, prices, dp); // buy
            int notSell = solve(day + 1, n, 0, prices, dp); // sell
            profit = max(sell, notSell);
        }
        return dp[day][buy] = profit;
    }
    int maxProfit(vector<int>& prices) {
        int n = prices.size();
        int buy = 1;
        vector<vector<int>> dp(n, vector<int>(2, -1));
        return solve(0, n, buy, prices, dp);
    }
};

// Method-2
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int n = prices.size();
        if(n < 2){
            return 0;
        }
        vector<int> dp(n, 0);
        dp[0] = 0;
        dp[1] = max(prices[1] - prices[0], 0);
        for(int i = 2; i < n; i++){
            dp[i] = dp[i - 1];
            for(int j = 0; j <= i - 1; j++){
                int todayProfit = prices[i] - prices[j];
                int prevProfit = (j >= 2) ? dp[j - 2] : 0;
                dp[i] = max(dp[i], todayProfit + prevProfit);
            }
        }
        return dp[n - 1];
    }
};

// Buy and Sell Stocks With Transaction Fee|(DP-40)

// Method-1
class Solution {
    int dfs(int i, int buy, int n, vector<int> &p, vector<vector<int>> &dp, int fee) {
        if(i == n) return 0;
        if(dp[i][buy] != -1) return dp[i][buy];
        if(buy) {
            return dp[i][buy] = max(-p[i] + dfs(i + 1, 0, n, p, dp, fee), dfs(i + 1, 1, n, p, dp, fee));
        }
        return dp[i][buy] = max(p[i] - fee + dfs(i + 1, 1, n, p, dp, fee), dfs(i + 1, 0, n, p, dp, fee));
    }
public:
    int maxProfit(vector<int>& p, int fee) {
        int n = p.size(), cnt = 0;
        vector<vector<int>> dp(n, vector<int>(2, -1));
        return dfs(0, 1, n, p, dp, fee);
    }
};

// Method-2

class Solution {
public:
    int maxProfit(vector<int>& p, int fee) {
        int n = p.size();
        vector<vector<int>> dp(n + 1, vector<int>(2));
        
        for(int i=n-1; i>=0; i--) {
            for(int buy=0; buy<=1; buy++) {
                if(buy) {
                    dp[i][buy] = max(-p[i] + dp[i + 1][0], dp[i + 1][1]);
                }
                else dp[i][buy] = max(p[i] - fee + dp[i + 1][1], dp[i + 1][0]);
            }
        }
        return dp[0][1];
    }
};

// Method-3
class Solution {
public:
    int maxProfit(vector<int>& p, int fee) {
        int n = p.size();
        vector<int> dp(2), temp(2);
        for(int i=n-1; i>=0; i--) {
            for(int buy=0; buy<=1; buy++) {
                if(buy) {
                    temp[buy] = max(-p[i] + dp[0], dp[1]);
                }
                else temp[buy] = max(p[i] - fee + dp[1], dp[0]);
            }
            dp = temp;
        }
        return dp[1];
    }
};

/* 7: DP on LIS */

// Longest Increasing Subsequence |(DP-41)

// Method-1
class Solution {
public:
     vector<int> dp;
     int lengthOfLIS(vector<int>& nums) {
         dp.resize(size(nums)+1, -1);
         return solve(nums, 0, -1);
     }
     int solve(vector<int>& nums, int i, int prev_i) {
         if(i >= size(nums)) return 0;
         if(dp[prev_i+1] != -1) return dp[prev_i+1];
         int take = 0, dontTake = solve(nums, i + 1, prev_i);
         if(prev_i == -1 || nums[i] > nums[prev_i])
             take = 1 + solve(nums, i + 1, i);
         return dp[prev_i+1] = max(take, dontTake);
     }
};

// Method-2
class Solution {
public:
     int lengthOfLIS(vector<int>& nums) {
         int ans = 1, n = size(nums);
         vector<int> dp(n, 1);
         for(int i = 0; i < n; i++) 
             for(int j = 0; j < i; j++) 
                 if(nums[i] > nums[j]) 
 			dp[i] = max(dp[i], dp[j] + 1), ans = max(ans, dp[i]);
         return ans;
     }
 };

// Method-3
class Solution {
public:
     int lengthOfLIS(vector<int>& A) {
         int len = 0;
         for(auto cur : A) 
             if(len == 0 || A[len-1] < cur) A[len++] = cur;             // extend
             else *lower_bound(begin(A), begin(A) + len, cur) = cur;    // replace
         return len;
     }
};

// Printing Longest Increasing Subsequence|(DP-42)

class Solution {
public:
    vector<int> longestIncreasingSubsequence(int n, vector<int>& arr) {
        vector<int> ans;
        vector<int> dp(n, 1);
        vector<int> hash(n);

        for (int i = 0; i < n; i++) {
            hash[i] = i;
            for (int prev_index = 0; prev_index < i; prev_index++) {
                if (arr[i] > arr[prev_index] && 1 + dp[prev_index] > dp[i]) {
                    dp[i] = 1 + dp[prev_index];
                    hash[i] = prev_index;
                }
            }
        }

        int max = -1, index = -1;
        for (int i = 0; i < n; i++) {
            if (max < dp[i]) {
                max = dp[i];
                index = i;
            }
        }

        ans.push_back(arr[index]);
        while (index != hash[index]) {
            index = hash[index];
            ans.push_back(arr[index]);
        }

        reverse(ans.begin(), ans.end());
        return ans;
    }
};

// Longest Increasing Subsequence |(DP-43)

int longestSubsequence(int n, int a[]){
        vector<int>dp;
        dp.push_back(a[0]);
        for(int i=1;i<n;i++){
            if(a[i]>dp.back()){
                dp.push_back(a[i]);
            }
            else{
                int ind=lower_bound(dp.begin(), dp.end(), a[i])-dp.begin();
                dp[ind]=a[i];
            }
        }
        return dp.size();
}

// Largest Divisible Subset|(DP-44)

// Method-1
class Solution {
public:
    vector<int> largestDivisibleSubset(vector<int>& nums) {
        sort(nums.begin(), nums.end());
        int n = nums.size();
        int maxi = 0;
        vector<int> dp(n, 1);
        vector<int> temp(n, -1);
        vector<int> ans;
        for (int i = 1; i < n; i++) {
            for (int j = 0; j < i; j++)
                if (nums[i] % nums[j] == 0 and dp[i] < dp[j] + 1)
                    dp[i] = dp[j] + 1, temp[i] = j;
            if (dp[i] > dp[maxi])
                maxi = i;
        }
        for (int i = maxi; i >= 0; i = temp[i])
            ans.push_back(nums[i]);
        return ans;
    }
};

// Method-2
class Solution {
public:
    vector<int> ans;
    void solve(vector<int>& nums, int i, vector<int>& temp, vector<int>& dp) {
        if (i == nums.size()) {
            if (temp.size() > ans.size())
                ans = temp;
            return;
        }
        if (temp.empty()) {
            temp.push_back(nums[i]);
            solve(nums, i + 1, temp, dp);
            temp.pop_back();
        } else if ((int)temp.size() > dp[i] && nums[i] % temp.back() == 0) {
            dp[i] = temp.size();
            temp.push_back(nums[i]);
            solve(nums, i + 1, temp, dp);
            temp.pop_back();
        }
        solve(nums, i + 1, temp, dp);
    }
    vector<int> largestDivisibleSubset(vector<int>& nums) {
        vector<int> temp;
        vector<int> dp(nums.size() + 1, -1);
        sort(nums.begin(), nums.end());
        solve(nums, 0, temp, dp);
        return ans;
    }
};

// Longest String Chain|(DP-45)

class Solution {
public:
    int longestStrChain(vector<string>& words) {
        int ans = 0;
        unordered_map<string, int> dp;

        sort(words.begin(), words.end(), sortByLength);
        for (string word : words) {
            for (int i = 0; i < word.length(); i++) {
                string predecessor = word.substr(0, i) + word.substr(i + 1);
                dp[word] = max(dp[word], dp[predecessor] + 1);
            }
            ans = max(ans, dp[word]);
        }
        return ans;
    }
    static bool sortByLength(string& s1, string& s2) {
        return s1.length() < s2.length();
    }
};

// Longest Bitonic Subsequence |(DP-46)

class Solution {
  public:
    int LongestBitonicSequence(int n, vector<int> &nums) {
        vector<int>dp1(n,1);
        vector<int>dp2(n,1);
        for(int i=0;i<n;i++){
            for(int j=0;j<i;j++){
                if(nums[j]<nums[i]&&dp1[i]<dp1[j]+1)
                dp1[i]=1+dp1[j];
            }
        }
        for(int i=n-1;i>=0;i--){
            for(int j=n-1;j>i;j--){
                if(nums[j]<nums[i]&&dp2[i]<dp2[j]+1)
                dp2[i]=1+dp2[j];
            }
        }
        int ans=0;
        for(int i=1;i<n-1;i++){
            if(dp1[i]>1&&dp2[i]>1)
            ans=max(ans,dp1[i]+dp2[i]-1);
        }
        return ans;
    }
};

// Number of Longest Increasing Subsequences|(DP-47)

class Solution {
public:
    int findNumberOfLIS(vector<int>& nums) {
        int n = nums.size();
        if (n == 0)
            return 0;

        vector<int> dp(n, 1), count(n, 1);
        int maxLength = 1;

        for (int i = 0; i < n; i++) {
            for (int j = 0; j < i; j++) {
                if (nums[i] > nums[j]) {
                    if (dp[i] < dp[j] + 1) {
                        dp[i] = dp[j] + 1;
                        count[i] = count[j];
                    } else if (dp[i] == dp[j] + 1) {
                        count[i] += count[j];
                    }
                }
            }
            maxLength = max(maxLength, dp[i]);
        }

        int numberOfLIS = 0;
        for (int i = 0; i < n; i++) {
            if (dp[i] == maxLength) {
                numberOfLIS += count[i];
            }
        }

        return numberOfLIS;
    }
};

/* 8: MCM DP | Partition DP */

// Matrix Chain Multiplication|(DP-48)

class Solution{
public:
    int t[501][501];
    int matrixMultiplication(int N, int arr[])
    {
        memset(t,-1,sizeof(t));
        // code here
        int i=1;int j=N-1;
        return sol(arr,i,j);
    }
    int sol(int arr[],int i,int j){
        
        int mn=INT_MAX;
        //base condition
        if(i>=j) return 0;
        
        //if matrix element is changed from -1 to any other  
        if(t[i][j]!=-1)
            return t[i][j];
        
        //main code
        for(int k=i;k<j;k++)
        {
            int temp= sol(arr,i,k)+sol(arr,k+1,j)+ arr[i-1]*arr[k]*arr[j];
            
            if(temp<mn)
                mn=temp;
        }
        return t[i][j]=mn;
    }
};

// Matrix Chain Multiplication | Bottom-Up|(DP-49)

class Solution{
public:
    int matrixMultiplication(int n, int arr[]){
        vector<vector<int>> dp(n,vector<int> (n,0));
        int i=0,j=1;
        while(j < n && i < n){
            dp[i][j] = 0;
            i++;
            j++;
        }
        for(int gap = 2; gap < n; gap++){
            int i = 0, j = gap;
            while(j < n && i < n){
                int store = INT_MAX;
                for(int k = i + 1; k < j; k++){
                  int val = dp[i][k] + dp[k][j];
                  val += arr[i] * arr[k] * arr[j];
                  store = min(store, val);
                }
                dp[i][j] = store;
                i++;
                j++;
            }
        }
        return dp[0][n - 1];
    }
};

// Minimum Cost to Cut the Stick|(DP-50)

// Method-1
class Solution
{
public:
    int f(int i, int j, vector<int> &cuts, vector<vector<int>> &dp){
        if (i > j)
            return 0;
        if (dp[i][j] != -1)
            return dp[i][j];
        int mini = 1e9;
        for (int ind = i; ind <= j; ind++){
            int cost = cuts[j + 1] - cuts[i - 1] + f(i, ind - 1, cuts, dp) + f(ind + 1, j, cuts, dp);
            mini = min(mini, cost);
        }
        return dp[i][j] = mini;
    }
    int minCost(int n, vector<int> &cuts){
        cuts.insert(cuts.begin(), 0);
        cuts.insert(cuts.end(), n);
        sort(cuts.begin(), cuts.end());
        int m = cuts.size();
        vector<vector<int>> dp(m + 1, vector<int>(m + 1, -1));
        return f(1, cuts.size() - 2, cuts, dp);
    }
};

// Method-2
class Solution
{
public:
    int minCost(int n, vector<int> &cuts){
        cuts.insert(cuts.begin(), 0);
        cuts.insert(cuts.end(), n);
        sort(cuts.begin(), cuts.end());
        int m = cuts.size();
        vector<vector<int>> dp(m, vector<int>(m, 0));
        for (int i = m - 1; i >= 1; i--){
            for (int j = i; j <= m - 2; j++){
                int mini = 1e9;
                for (int ind = i; ind <= j; ind++){
                    int cost = cuts[j + 1] - cuts[i - 1] + dp[i][ind - 1] + dp[ind + 1][j];
                    mini = min(mini, cost);
                }
                dp[i][j] = mini;
            }
        }
        return dp[1][cuts.size() - 2];
    }
};

// Burst Balloons|(DP-51)

// Method-1
class Solution {
public:
    int dp[400][400];
    int f(int i, int j, vector<int>& v) {
        if (i > j)
            return 0;
        if (dp[i][j] != -1)
            return dp[i][j];
        int ans = -1;
        for (int k = i; k <= j; k++) {
            ans = max(ans, v[i - 1] * v[k] * v[j + 1] + f(i, k - 1, v) + f(k + 1, j, v));
        }
        return dp[i][j] = ans;
    }
    int maxCoins(vector<int>& nums) {
        int n = nums.size();
        nums.insert(nums.begin(), 1);
        nums.push_back(1);
        memset(dp, -1, sizeof dp);
        return f(1, n, nums);
    }
};

// Method-2
class Solution {
public:
    int dp[400][400];
    int maxCoins(vector<int>& nums) {
        int n = nums.size();
        nums.insert(nums.begin(), 1);
        nums.push_back(1);
        for(int i = 0; i < n; i++){
            for(int j = 0; j < n; j++){
                if(i > j)
			dp[i][j] = 0;
            }
        }
        for(int i = n; i >= 1; i--){
            for(int j = i; j <= n; j++){
                int ans = -1;
                for(int k = i; k <= j; k++){
                    ans=max(ans,nums[i - 1] * nums[k] * nums[j + 1] + dp[i][k - 1] + dp[k + 1][j]);
                }
                dp[i][j] = ans;
            }
        }
        return dp[1][n];
    }
};

// Evaluate Boolean Expression to True|(DP-52)

class Solution {
public:
    char solver(vector<char> values, char op) {
        switch(op) {
            case '&' : {
                if(count(values.begin(), values.end(), 'f'))
                    return 'f';
                break;
            } 
            case '|' : {
                if(count(values.begin(), values.end(), 't'))
                    return 't';
                return 'f';
            }
            case '!' : {
                return values[0] == 't' ? 'f' : 't';
            }
        }
        return 't';
    }
    char helper(int &index, string &exp) {
        char op = exp[index++];
        index++; // (
        vector<char> vals;
        while(index < exp.length() && exp[index] != ')') {
            if(exp[index] == 't')
                vals.push_back('t'), index++;
            else if(exp[index] == 'f')
                vals.push_back('f'), index++;
            else if(exp[index] == ',')
                index++;
            else
                vals.push_back(helper(index, exp));
        }
        index++; // )
        return solver(vals, op);
    }
    bool parseBoolExpr(string expression) {
        int index = 0;
        return helper(index, expression) == 't';
    }
};

// Palindrome Partitioning - II|(DP-53)

// Method-1
class Solution {
public:
    int dp[2001][2001];
    bool isPalindrome(string s, int i, int j) {
        while (i < j) {
            if (s[i] != s[j]) {
                return false;
            } else {
                i++;
                j--;
            }
        }
        return true;
    }
    int solve(string s, int i, int j) {
        if (i >= j) {
            return 0;
        }
        if (dp[i][j] != -1) {
            return dp[i][j];
        }
        if (isPalindrome(s, i, j)) {
            return 0;
        }
        int ans = INT_MAX;
        for (int k = i; k < j; k++) {
            int temp = 1 + solve(s, i, k) + solve(s, k + 1, j);
            dp[i][j] = ans = min(ans, temp);
        }
        return dp[i][j];
    }
    int minCut(string s) {
        int n = s.length();
        memset(dp, -1, sizeof(dp));
        int ans = solve(s, 0, n - 1);
        return ans;
    }
};

// Method-2
class Solution {
public:
    int dp[2001];
    bool isPalindrome(const std::string& s, int i, int j) {
        while (i < j) {
            if (s[i] != s[j]) {
                return false;
            } else {
                i++;
                j--;
            }
        }
        return true;
    }

    int minCut(const std::string& s) {
        int n = s.length();
        std::vector<std::vector<bool>> isPal(n, std::vector<bool>(n, false));

        for (int i = 0; i < n; i++) {
            isPal[i][i] = true;
        }

        for (int len = 2; len <= n; len++) {
            for (int i = 0; i <= n - len; i++) {
                int j = i + len - 1;
                if (s[i] == s[j] && (len == 2 || isPal[i + 1][j - 1])) {
                    isPal[i][j] = true;
                }
            }
        }

        for (int i = 0; i < n; i++) {
            dp[i] = i; // Maximum possible cuts for the substring s[0:i]
        }

        for (int i = 1; i < n; i++) {
            if (isPal[0][i]) {
                dp[i] = 0;
            } else {
                for (int j = 0; j < i; j++) {
                    if (isPal[j + 1][i]) {
                        dp[i] = min(dp[i], dp[j] + 1);
                    }
                }
            }
        }
        return dp[n - 1];
    }
};

// Partition Array for Maximum Sum|(DP-54)

// Method-1
class Solution {
public:
    vector<int> dp;
    int solve(vector<int>& arr, int k, int ind) {
        int n = arr.size(), mx = 0, ans = 0;
        if (ind >= n) {
            return 0;
        }
        if (dp[ind] != -1) {
            return dp[ind];
        }
        for (int i = ind; i < min(ind + k, n); i++) {
            mx = max(mx, arr[i]);
            ans = max(ans, (i - ind + 1) * mx + solve(arr, k, i + 1));
        }
        dp[ind] = ans;
        return ans;
    }
    int maxSumAfterPartitioning(vector<int>& arr, int k) {
        dp.resize(arr.size(), -1);
        return solve(arr, k, 0);
    }
};

// Method-2
class Solution {
public:
    int bottomup(int i, vector<int>& arr, int k) {
        // base case
        vector<int> dp(arr.size() + 1, 0);
        dp[0] = 0;
        for (int i = arr.size() - 1; i >= 0; i--) {
            int currAns = 0;
            int maxEle = arr[i];
            int count = 0;
            for (int j = i; j < arr.size() && count < k; j++) {
                maxEle = max(maxEle, arr[j]);
                count++;
                int sum = maxEle * count;
                currAns = max(currAns, sum + dp[j + 1]);
            }
            dp[i] = currAns;
        }
        return dp[0];
    }
    int maxSumAfterPartitioning(vector<int>& arr, int k) {
        int n = arr.size();
        return bottomup(0, arr, k);
    }
};

/* 9: DP on Squares */

// Maximum Rectangle Area with all 1's|(DP-55)

class Solution {
public:
    vector<int> nextSmallerElement(vector<int> arr, int n) {
        stack<int> s;
        vector<int> ans(n);
        for (int i = n - 1; i >= 0; i--) {
            while (!s.empty() && arr[s.top()] >= arr[i]) {
                s.pop();
            }
            if (s.empty()) {
                ans[i] = n;
            } else {
                ans[i] = s.top();
            }
            s.push(i);
        }
        return ans;
    }
    vector<int> prevSmallerElement(vector<int> arr, int n) {
        stack<int> s;
        vector<int> ans(n);
        for (int i = 0; i < n; i++) {
            while (!s.empty() && arr[s.top()] >= arr[i]) {
                s.pop();
            }
            if (s.empty()) {
                ans[i] = -1;
            } else {
                ans[i] = s.top();
            }
            s.push(i);
        }
        return ans;
    }
    int largestRectangleArea(vector<int>& heights) {
        int n = heights.size();
        vector<int> next(n);
        next = nextSmallerElement(heights, n);
        vector<int> prev(n);
        prev = prevSmallerElement(heights, n);
        int area = INT_MIN;
        for (int i = 0; i < n; i++) {
            int l = heights[i];
            int b = next[i] - prev[i] - 1;
            int newArea = l * b;
            area = max(area, newArea);
        }
        return area;
    }
    int maximalRectangle(vector<vector<char>>& matrix) {
        if (matrix.empty() || matrix[0].empty()) {
            return 0;
        }
        int rows = matrix.size();
        int cols = matrix[0].size();
        vector<int> heights(cols, 0);
        int maxArea = 0;
        for (int i = 0; i < rows; ++i) {
            for (int j = 0; j < cols; ++j) {
                heights[j] = (matrix[i][j] == '1') ? heights[j] + 1 : 0;
            }
            maxArea = max(maxArea, largestRectangleArea(heights));
        }
        return maxArea;
    }
};

// Count Square Submatrices with All Ones|(DP-56)

class Solution {
public:
    vector<int> prevSmaller(vector<int>& heights, int n) {
        stack<int> st;
        st.push(-1);
        vector<int> ans(n);
        for (int i = 0; i < n; ++i) {
            int curr = heights[i];
            while (st.top() != -1 && heights[st.top()] >= curr) {
                st.pop();
            }
            ans[i] = st.top();
            st.push(i);
        }
        return ans;
    }
    int solve(vector<int>& heights) {
        int r = 0;
        int n = heights.size();
        vector<int> prev = prevSmaller(heights, n);
        for (int i = 0; i < n; i++) {
            bool is_sq = true;
            for (int h = 0; h < heights[i]; h++) {
                if (h > i) {
                    break;
                }
                for (int x = i; x >= i - h; x--) {
                    if (heights[x] < h + 1) {
                        is_sq = false;
                        break;
                    }
                }
                if (!is_sq) {
                    break;
                }
                r += 1;
            }
        }
        return r;
    }
    int countSquares(vector<vector<int>>& matrix) {
        int row = matrix.size();
        int col = matrix[0].size();
        vector<int> heights(col, 0);
        int maxi = 0;
        for (int i = 0; i < row; i++) {
            for (int j = 0; j < col; j++) {
                if (matrix[i][j] == 1)
                    heights[j]++;
                else
                    heights[j] = 0;
            }
            maxi += solve(heights);
        }
        return maxi;
    }
};
