/* Step 3.1: Easy */

// Largest Element in an Array		

#include <bits/stdc++.h> 
int largestElement(vector<int> &arr, int n) {
    int max=INT_MIN;
    for(int i=0;i<n;i++){
        if(arr[i]>max){
            max=arr[i];
        }
    }
    return max;
}

// Second Largest and Minimum Element in an Array …		

vector<int> getSecondOrderElements(int n, vector<int> arr)
{
    int maxi = INT_MIN, mini = INT_MAX;
    for (int i = 0; i < n; i++)
    {
        maxi = max(maxi, arr[i]);
        mini = min(mini, arr[i]);
    }
    int secMaxi = INT_MIN, secMini = INT_MAX;
    for (int i = 0; i < n; i++)
    {
        if (arr[i] != maxi)
        {
            secMaxi = max(secMaxi, arr[i]);
        }
        if (arr[i] != mini)
        {
            secMini = min(secMini, arr[i]);
        }
    }
    return {secMaxi, secMini};
}

// Check if the array is sorted		
	
// Coding Ninja
int isSorted(int n, vector<int> a) {
    for(int i=1;i<n;i++){
        if(a[i-1]>a[i]){
            return 0;
        }
    }
    return 1;
}

// Leetcode (Sorted and Rotated)
class Solution {
public:
    bool check(vector<int>& nums) {
        int count = 0;
        for(int i=0;i<nums.size()-1;i++)
        {
            if(nums[i] > nums[i+1]){
                count++;
            }
        }
        if(nums[nums.size()-1] > nums[0]){
            count++;
        }
        if(count <= 1){
            return true;
        }
        else{
            return false;
        }
    }
};

// Remove duplicates from Sorted array		
	
int removeDuplicates(vector<int> &nums, int n) {
	int ans = 1;
	for (int i = 1; i < nums.size(); i++) {
		if (nums[i] != nums[i - 1]) {
			nums[ans] = nums[i];
			ans++;
		}
	}
	return ans;
}

// Left Rotate an array by one place		
	
// Method-1
#include <bits/stdc++.h> 
vector<int> rotateArray(vector<int>& arr, int n) {
    int temp = arr[0];
    for(int i = 1; i < n;i++){
        arr[i-1] = arr[i];
    }
    arr[n-1] = temp;
    return arr;
}

// Method-2
#include <bits/stdc++.h> 
vector<int> rotateArray(vector<int>& arr, int n){
    reverse(arr.begin()+1,arr.end());
    reverse(arr.begin(),arr.end());
    return arr;
}

// Left rotate an array by K places		
	
vector<int> rotateArray(vector<int> arr, int k) {
    reverse(arr.begin(), arr.begin() + k);
    reverse(arr.begin() + k, arr.end());
    reverse(arr.begin(), arr.end());
    return arr;
}

// Move Zeros to end		
	
vector<int> moveZeros(int n, vector<int> a) {
    int i=0,j=0;
    while(i<n){
        if(a[i]!=0){
            swap(a[i],a[j]);
            i++;
            j++;
        }
        else{
            i++;
        }
    }
    return a;
}

// Linear Search		

int linearSearch(int n, int num, vector<int> &arr)
{
    for(int i=0;i<n;i++){
        if(arr[i]==num){
            return i;
        }
    }
    return -1;
}

// Find the Union		

// Method-1
#include <bits/stdc++.h>
vector<int> sortedArray(vector<int> arr1, vector<int> arr2)
{
    set<int> s;
    vector<int> Union;
    for (int i = 0; i < arr1.size(); i++)
        s.insert(arr1[i]);
    for (int i = 0; i < arr2.size(); i++)
        s.insert(arr2[i]);
    for (auto &it : s)
        Union.push_back(it);
    return Union;
}

// Method-2
#include <bits/stdc++.h>
vector<int> sortedArray(vector<int> arr1, vector<int> arr2)
{
    int i = 0, j = 0; // pointers
    int n = arr1.size();
    int m = arr2.size();
    vector<int> Union; // Union vector
    while (i < n && j < m)
    {
        if (arr1[i] <= arr2[j]) // Case 1 and 2
        {
            if (Union.size() == 0 || Union.back() != arr1[i])
                Union.push_back(arr1[i]);
            i++;
        }
        else // case 3
        {
            if (Union.size() == 0 || Union.back() != arr2[j])
                Union.push_back(arr2[j]);
            j++;
        }
    }
    while (i < n) // IF any element left in arr1
    {
        if (Union.back() != arr1[i])
            Union.push_back(arr1[i]);
        i++;
    }
    while (j < m) // If any elements left in arr2
    {
        if (Union.back() != arr2[j])
            Union.push_back(arr2[j]);
        j++;
    }
    return Union;
}

// Find missing number in an array		
	


// Maximum Consecutive Ones		
	


// Find the number that appears once, …		
	


// Longest subarray with given sum K(p…		



// Longest subarray with sum K (Positives + Negatives)

