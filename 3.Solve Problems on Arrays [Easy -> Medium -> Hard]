/* Step 3.1: Easy */

// Largest Element in an Array		

#include <bits/stdc++.h> 
int largestElement(vector<int> &arr, int n) {
    int max=INT_MIN;
    for(int i=0;i<n;i++){
        if(arr[i]>max){
            max=arr[i];
        }
    }
    return max;
}

// Second Largest and Minimum Element in an Array â€¦		

vector<int> getSecondOrderElements(int n, vector<int> arr)
{
    int maxi = INT_MIN, mini = INT_MAX;
    for (int i = 0; i < n; i++)
    {
        maxi = max(maxi, arr[i]);
        mini = min(mini, arr[i]);
    }
    int secMaxi = INT_MIN, secMini = INT_MAX;
    for (int i = 0; i < n; i++)
    {
        if (arr[i] != maxi)
        {
            secMaxi = max(secMaxi, arr[i]);
        }
        if (arr[i] != mini)
        {
            secMini = min(secMini, arr[i]);
        }
    }
    return {secMaxi, secMini};
}

// Check if the array is sorted		
	
// Coding Ninja
int isSorted(int n, vector<int> a) {
    for(int i=1;i<n;i++){
        if(a[i-1]>a[i]){
            return 0;
        }
    }
    return 1;
}

// Leetcode (Sorted and Rotated)
class Solution {
public:
    bool check(vector<int>& nums) {
        int count = 0;
        for(int i=0;i<nums.size()-1;i++)
        {
            if(nums[i] > nums[i+1]){
                count++;
            }
        }
        if(nums[nums.size()-1] > nums[0]){
            count++;
        }
        if(count <= 1){
            return true;
        }
        else{
            return false;
        }
    }
};

// Remove duplicates from Sorted array		
	
int removeDuplicates(vector<int> &nums, int n) {
	int ans = 1;
	for (int i = 1; i < nums.size(); i++) {
		if (nums[i] != nums[i - 1]) {
			nums[ans] = nums[i];
			ans++;
		}
	}
	return ans;
}

// Left Rotate an array by one place		
	
// Method-1
#include <bits/stdc++.h> 
vector<int> rotateArray(vector<int>& arr, int n) {
    int temp = arr[0];
    for(int i = 1; i < n;i++){
        arr[i-1] = arr[i];
    }
    arr[n-1] = temp;
    return arr;
}

// Method-2
#include <bits/stdc++.h> 
vector<int> rotateArray(vector<int>& arr, int n){
    reverse(arr.begin()+1,arr.end());
    reverse(arr.begin(),arr.end());
    return arr;
}

// Left rotate an array by K places		
	
vector<int> rotateArray(vector<int> arr, int k) {
    reverse(arr.begin(), arr.begin() + k);
    reverse(arr.begin() + k, arr.end());
    reverse(arr.begin(), arr.end());
    return arr;
}

// Move Zeros to end		
	
vector<int> moveZeros(int n, vector<int> a) {
    int i=0,j=0;
    while(i<n){
        if(a[i]!=0){
            swap(a[i],a[j]);
            i++;
            j++;
        }
        else{
            i++;
        }
    }
    return a;
}

// Linear Search		

int linearSearch(int n, int num, vector<int> &arr)
{
    for(int i=0;i<n;i++){
        if(arr[i]==num){
            return i;
        }
    }
    return -1;
}

// Find the Union		

// Method-1
#include <bits/stdc++.h>
vector<int> sortedArray(vector<int> arr1, vector<int> arr2)
{
    set<int> s;
    vector<int> Union;
    for (int i = 0; i < arr1.size(); i++)
        s.insert(arr1[i]);
    for (int i = 0; i < arr2.size(); i++)
        s.insert(arr2[i]);
    for (auto &it : s)
        Union.push_back(it);
    return Union;
}

// Method-2
#include <bits/stdc++.h>
vector<int> sortedArray(vector<int> arr1, vector<int> arr2)
{
    int i = 0, j = 0; // pointers
    int n = arr1.size();
    int m = arr2.size();
    vector<int> Union; // Union vector
    while (i < n && j < m)
    {
        if (arr1[i] <= arr2[j]) // Case 1 and 2
        {
            if (Union.size() == 0 || Union.back() != arr1[i])
                Union.push_back(arr1[i]);
            i++;
        }
        else // case 3
        {
            if (Union.size() == 0 || Union.back() != arr2[j])
                Union.push_back(arr2[j]);
            j++;
        }
    }
    while (i < n) // IF any element left in arr1
    {
        if (Union.back() != arr1[i])
            Union.push_back(arr1[i]);
        i++;
    }
    while (j < m) // If any elements left in arr2
    {
        if (Union.back() != arr2[j])
            Union.push_back(arr2[j]);
        j++;
    }
    return Union;
}

// Find missing number in an array		
	
class Solution {
public:
    int missingNumber(vector<int>& nums) {
    int sum1=0;
    int n=nums.size();
    for(int i=0;i<n;i++){
        sum1=sum1+nums[i];
    }
    int sum2=(n*(n+1))/2;
    return sum2-sum1;
    }
};

// Maximum Consecutive Ones		

// Coding Ninja
int traffic(int n, int m, vector<int> arr) {
	int i = 0, j = 0, ans = INT_MIN, zero = 0;
	while (i < n) {
		if (arr[i] == 0) {
			zero++;
		}
		while (zero > m) {
			if (arr[j] == 0) {
				zero--;
			}
			j++;
		}
		ans = max(ans, i - j + 1);
		i++;
	}
	return ans;
}

// Leetcode
class Solution {
public:
    int findMaxConsecutiveOnes(vector<int>& arr) {
        int n = arr.size();
        int ans = INT_MIN;
        int count=0;
        for(int i=0;i<n;i++){
            if(arr[i]==1){
                count++;
            }
            else{
                count=0;
            }
            ans = max(ans,count);
        }
        return ans;
    }
};

// Find the number that appears once and other numbers twice	
	
// Method-1 [ Coding Ninja ] 
#include<bits/stdc++.h>

int getSingleElement(vector<int> &arr){
	unordered_map<int,int> m;
	int ans;
	int n = arr.size();
	for(int i = 0; i < n; i++){
		m[arr[i]]++;
	}
	for(auto p : m){
		if(p.second==1){
			ans = p.first;
		}
	}
	return ans;
}

// Method-2 [ Coding Ninja ]
#include <vector>
int getSingleElement(vector<int> &arr) {
	for (int i = 0; i < arr.size(); i++) {
		if (arr[i] != arr[i + 1]) {
			return arr[i];
		} 
		else if (arr[i] == arr[i + 1]) {
			i++;
		}
	}
}

// Leetcode
// Method-1
class Solution {
public:
    int singleNumber(vector<int>& nums) { 
       int ans=0;
	   for(auto x:nums){
	       ans^=x;
       }
	   return ans;
    }
};

// Method-2
class Solution {
public:
    int singleNumber(vector<int>& nums) { 
        sort(nums.begin(),nums.end());
        for(int i=1;i<nums.size();i+=2)
        {
            if(nums[i]!=nums[i-1])
                return nums[i-1];
        }
        return nums[nums.size()-1];
    }
};

// Longest subarray with given sum K(Positives)	

// Method-1
#include <bits/stdc++.h>
int longestSubarrayWithSumK(vector<int> a, long long k) {
    unordered_map<int, int> m;
    int sum = 0, maxLen = 0;
    for (int i = 0; i < a.size(); i++) {
        sum += a[i];
        if (sum == k) {
            maxLen = i + 1;
        }
        if (m.find(sum) == m.end()) {
            m[sum] = i;
        }
        if (m.find(sum - k) != m.end()) {
            maxLen = max(maxLen, i - m[sum - k]);
        }
    }
    return maxLen;
}

// Method-2
int longestSubarrayWithSumK(vector<int> &nums, long long targetSum) {
    int right = 0, left = 0;
    int maxSubarrayLength = 0;
    int n = nums.size();
    long long currentSum = 0;
    while (right < n) {
        while (currentSum > targetSum && left <= right) {
            currentSum -= nums[left];
            left++;
        }
        if (currentSum == targetSum) {
            maxSubarrayLength = max(maxSubarrayLength, right - left);
        }
        if (right < n) {
            currentSum += nums[right++];
        }
    }
    int result;
    if (currentSum == targetSum) {
        result = max(maxSubarrayLength, right - left);
    }
    else {
        result = maxSubarrayLength;
    }
    return result;
}

// Longest subarray with sum K (Positives + Negatives)

#include <bits/stdc++.h>

int getLongestSubarray(vector<int> &nums, int k) {
    int ans=0;
    unordered_map<int,int> prefix_sum;
    int sum=0;
    for(int i=0;i<nums.size();i++){
        sum=sum+nums[i];
        if(sum==k) ans=max(ans,i+1);
        else{
            int rem=sum-k;
            if(prefix_sum.find(rem)!=prefix_sum.end()){
                int temp=i-prefix_sum[rem];
                ans=max(ans,temp);
            }
            if(prefix_sum.find(sum)==prefix_sum.end()){
                prefix_sum[sum]=i;
            }
        }
    }
    return ans;
}

/* Step 3.2: Medium */

// Two Sum

// Coding Ninja
#include <algorithm>
string read(int n, vector<int> book, int target) {
    sort(book.begin(), book.end());
    int i = 0, j = book.size() - 1;
    while (i < j) {
        if (book[i] + book[j] < target)
            i++;
        else if (book[i] + book[j] > target)
            j--;
        else
            return "YES";
    }
    return "NO";
}

// Leetcode
// Method-1 [ Brute Force Code ]
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        for (int i = 0; i < nums.size(); i++) {
            for (int j = i + 1; j < nums.size(); j++) {
                if (nums[i] + nums[j] == target) {
                    return {i, j};
                }
            }
        }
        return {};
    }
};

// Method-2 [ Optimized Code ]
#include <unordered_map>
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        unordered_map<int, int> mp;
        for(int i = 0; i < nums.size(); i++){
            if(mp.find(target - nums[i]) == mp.end())
                mp[nums[i]] = i;
            else
                return {mp[target - nums[i]], i};
        }
        return {-1, -1};
    }
};

// Sort an array of 0's 1's and 2's		
	
// Coding Ninjas
#include <bits/stdc++.h> 
void sortArray(vector<int>& arr, int n)
{
    int a0=0,b1=0,c2=n-1;
    while(b1<=c2){
        if(arr[b1]==0){
            swap(arr[a0],arr[b1]);
            a0++;
            b1++;
        }
        else if(arr[b1]==1){
            b1++;
        }
        else{
            swap(arr[b1],arr[c2]);
            c2--;
        }
    }
}

// Leetcode
class Solution {
public:
    void sortColors(vector<int>& nums) {
        int a0=0,b1=0,c2=nums.size()-1;
        while(b1<=c2){
            if(nums[b1]==0){
                swap(nums[a0],nums[b1]);
                a0++;
                b1++;
            }
            else if(nums[b1]==1){
                b1++;
            }
            else{
                swap(nums[b1],nums[c2]);
                c2--;
            }
        }
    }
};

// Majority Element (>n/2 times)		
	
// Coding Ninja
//Method-1
#include<bits/stdc++.h>
int majorityElement(vector<int> v) {
    int n=v.size();
    map<int,int> m;
    for(int i=0;i<n;i++){
        m[v[i]]++;
    }
    for(auto it:m){
        if(it.second>n/2){
            return it.first;
        }
    }
}

// Method-2
#include<bits/stdc++.h>
int majorityElement(vector<int> v){
    sort(v.begin(),v.end());
    return v[v.size()/2];
}

// Method-3 [ Moore's Voting Algorithm ]
#include <bits/stdc++.h>
int majorityElement(vector<int> v) {
    int count = 0;
    int candidate = 0;
    for (int i = 0; i < v.size(); i++) {
    	if (count == 0) {
		candidate = v[i];
		count++;
	} 
	else if (v[i] == candidate) {
		count++;
	}
	else {
      		count--;
    	}
    }
    count = 0;
    for (int num : v) {
	if (num == candidate) {
		count++;
	}
    }
    if (count > v.size() / 2) {
	return candidate;
    } 
    else {
	return -1;
    }
}

// Leetcode
class Solution {
public:
    int majorityElement(vector<int>& nums) {
        int count=0;
        int candidate=0;
        for(int i=0;i<nums.size();i++){
            if(count==0){
                candidate=nums[i];
                count++;
            }
            else if(nums[i]==candidate){
                count++;
            }
            else{
                count--;
            }
        }
        count=0;
        for(int n:nums){
            if(n==candidate){
                count++;
            }
        }
        if(count>nums.size()/2){
            return candidate;
        }
        else{
            return -1;
        }
    }
};

// Kadane's Algorithm, largest sum contiguos subarray		
	


// Print subarray with maximum subarraâ€¦		



// Stock Buy and Sell		
	


// Rearrange the array in alternating â€¦		
	


// Next Permutation		
	


// Leaders in an Array problem		



// Longest Consecutive Sequence in an â€¦		
	


// Set Matrix Zeros		
	


// Rotate Matrix by 90 degrees		
	


// Print the matrix in spiral manner		
	


// Count subarrays with given sum
