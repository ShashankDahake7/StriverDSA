/* Step 4.1: BS on 1D Arrays */

// Binary Search to find X in sorted a…		

// Method-1
class Solution {
public:
    int search(vector<int>& nums, int target) {
        int left=0;
        int right=nums.size()-1;
        while(left<=right){
            int mid=left+(right-left)/2;
            if(nums[mid]==target){
                return mid;
            }
            else if(nums[mid]<target){
                left=mid+1;
            }
            else{
                right=mid-1;                
            }
        }
        return -1;
    }
};

// Method-2
int BinarySearch(int arr[],int s,int e,int k){
    int mid=s+(e-s)/2;
    if(s>e){
        return -1;
    }
    if(arr[mid]==k){
        return mid;
    }
    if(arr[mid]<k){
        return BinarySearch(arr, mid+1, e, k);
    }
    else{
        return BinarySearch(arr,s,mid-1,k);
    }
}
int binarySearch(int *input, int n, int val){
    int ans=BinarySearch(input, 0, n-1, val);
    return ans;
}

// Implement Lower Bound		

int lowerBound(vector<int> arr, int n, int x) {
	int left=0;
	int right=n-1;
	int ans=n;
	while(left<=right){
	  int mid=left+(right-left)/2;
		if(arr[mid]>=x){
			ans=mid;
			right=mid-1;
		}
		else{
			left=mid+1;
		}
	}
	return ans;
}

// Implement Upper Bound		

int upperBound(vector<int> &arr, int x, int n){
	int left=0;
	int right=n-1;
	int ans=n;
	while(left<=right){
		int mid=left+(right-left)/2;
		if(arr[mid]>x){
			ans=mid;
			right=mid-1;
		}
		else{
			left=mid+1;			
		}
	}	
	return ans;
}

// Search Insert Position		
	
int searchInsert(vector<int>& arr, int x) {
    int n = arr.size();
    int left = 0, right = n - 1;
    int ans = n;
    while (left <= right) {
        int mid = (left + right) / 2;
        if (arr[mid] >= x){
            ans = mid;
            right = mid - 1;
        }
        else {
            left = mid + 1;
        }
    }
    return ans;
}

// Floor/Ceil in Sorted Array		

#include <bits/stdc++.h>
pair<int, int> getFloorAndCeil(vector<int> &a, int n, int x) {
    pair<int, int>p;
    int left=0, right=a.size()-1, floor=-1, ceil=-1;
    while(left<=right){
        int mid=left+(right-left)/2;
        if(a[mid]==x){
            floor=a[mid];
            ceil=a[mid];
            break;
        }
        else if(a[mid]<=x){
            floor=a[mid];
            left=mid+1;
        }
        else if(a[mid]>=x){
            ceil=a[mid];
            right=mid-1;
        }
    }
    return {floor, ceil};
}

// Find the first or last occurrence of a given number in a sorted array	
	
#include <bits/stdc++.h> 
int FirstOccurence(vector<int>& arr, int n, int k){
    int left=0,right=n-1,mid=left+(right-left)/2;
    int ans=-1;
    while(left<=right){
        if(arr[mid]<k){
            left=mid+1;
        }
        else if(arr[mid]==k){
            ans=mid;
            right=mid-1;
        }
        else{
            right=mid-1;
        }
        mid=left+(right-left)/2;
    }
    return ans;
}
int LastOccurence(vector<int>& arr, int n, int k){
    int left=0,right=n-1,mid=left+(right-left)/2;
    int ans=-1;
    while(left<=right){
        if(arr[mid]<k){
            left=mid+1;
        }
        else if(arr[mid]==k){
            ans=mid;
            left=mid+1;
        }
        else{
            right=mid-1;
        }
        mid=left+(right-left)/2;
    }
    return ans;
}
pair<int, int> firstAndLastPosition(vector<int>& arr, int n, int k){
    pair<int,int> p;
    p.first=FirstOccurence(arr,n,k);
    p.second=LastOccurence(arr,n,k);
    return p;
}

// Count occurrences of a number in a sorted array with duplicates		

int FirstOccurence(vector<int>& arr, int n, int k){
    int left=0,right=n-1,mid=left+(right-left)/2;
    int ans=0;
    while(left<=right){
        if(arr[mid]<k){
            left=mid+1;
        }
        else if(arr[mid]==k){
            ans=mid;
            right=mid-1;
        }
        else{
            right=mid-1;
        }
        mid=left+(right-left)/2;
    }
    return ans;
}
int LastOccurence(vector<int>& arr, int n, int k){
    int left=0,right=n-1,mid=left+(right-left)/2;
    int ans=-1;
    while(left<=right){
        if(arr[mid]<k){
            left=mid+1;
        }
        else if(arr[mid]==k){
            ans=mid;
            left=mid+1;
        }
        else{
            right=mid-1;
        }
        mid=left+(right-left)/2;
    }
    return ans;
}
int count(vector<int>& arr, int n, int x) {
	int first= FirstOccurence(arr,n,x);
    int last = LastOccurence(arr, n, x);
    return (last-first+1);
}

// Search in Rotated Sorted Array I		
	
class Solution {
public:
    int search(vector<int>& nums, int target) {
        int n=nums.size();
        int left=0;
        int right=n-1;
        int mid=left+(right-left)/2;
        while(left<=right){
             mid=left+(right-left)/2;
             if(nums[mid]==target){
                return mid;    
             } 
             if(nums[left]<=nums[mid]){
                 if(nums[left]<=target && target<=nums[mid]){
                     right=mid-1;
                 }
                 else{ 
                     left=mid+1;
                 }
             }
             else{
                if(nums[mid]<=target && target<=nums[right]){
                    left=mid+1;
                }
                else{
                    right=mid-1;
                }
             }
        }
        return -1;
    }
};

// Search in Rotated Sorted Array II		
	
class Solution {
public:
    bool search(vector<int>& nums, int target) {
        int n=nums.size();
        int left=0;
        int right=n-1;
        while(left<=right){
            int mid=left+(right-left)/2;
            if(nums[mid]==target){
                return true;
            }
            else if(nums[left]==nums[mid] && nums[right]==nums[mid]){
                left++;
                right--;
                continue;
            }
            else if(nums[left]<=nums[mid]){
                if(nums[left]<=target && target<=nums[mid]){
                    right=mid-1;
                }
                else{
                    left=mid+1;
                }
            }
            else{
                if(nums[mid]<=target && target<=nums[right]){
                    left=mid+1;
                }
                else{
                    right=mid-1;
                }
            }
        }
        return false;
    }
};

// Find minimum in Rotated Sorted Array
	
int findMin(vector<int>& arr){
    int n=arr.size();
    int left = 0;
    int right =n-1;
    int ans=INT_MAX;
    while(left<=right){
        int mid = left +(right-left)/2;
		    // right half sorted
        if(arr[left]>arr[mid]) {
            ans=min(ans,arr[mid]);
            right=mid-1;
        } 
		    // left half is sorted 
        else if(arr[left]<=arr[mid]){
            ans=min(ans ,arr[left]);
            left=mid+1;
        }
    }
    return ans;
}

// Find out how many times has an array been rotated

int findKRotation(vector<int> &arr){
    int left=0;
    int right=arr.size()-1;
    int mid;
    if(arr[left]<=arr[right]){
        return 0;
    }
    while(left<=right){
        int mid=left+(right-left)/2;
        if(arr[mid+1]<arr[mid]){
            return mid+1;
        }
        else if(arr[mid]>=arr[left]){
            left=mid+1;
        }
        else{
            right=mid-1;
        }
    }
    return mid+1;
}

// Single element in a Sorted Array		
	
int singleNonDuplicate(vector<int>& arr){
    int left = 0 ;
    int right = arr.size() - 2;
    while(left<=right){
        int mid = left+(right-left)/2;
        if(mid%2!=0){
            if(arr[mid] == arr[mid-1]){
                left = mid+1;
            }
            else{
                right = mid-1;
            }
		}
        else{
            if(arr[mid] == arr[mid+1]){
				left = mid+1;
			}
            else{
				right = mid-1;
			}
        }
    }
    return arr[left];
}

// Find peak element

int findPeakElement(vector<int> &arr) {
    int n=arr.size();
    int left=0;
    int right=n-1;
    while(left<=right){
        int mid= left+ (right-left)/2;
        if(arr[mid]>arr[mid-1] && arr[mid]>arr[mid+1]){
            return mid;
        }
        else if(arr[mid]<arr[left]){
            right=mid-1;
        }
        else{
            left=mid+1;
        }
    }
}

/* Step 4.2: BS on Answers */

// Find square root of a number in logN

#include <bits/stdc++.h> 
int sqrtN(long long int N){
    if(N < 2){
        return N;
    }
    long long int left = 0, right = N;
    long long ans = -1;
    while (left <= right){
        long long int mid = left + (right - left) / 2;
        // same as mid*mid == N, to avoid range overlow
        if (mid  == (N/mid)){
            return mid;
        }
        else if (mid > (N/mid)){
            right = mid - 1;
        }
        else{
            ans = mid;
            left = mid + 1;
        }
    }
    return ans;
}

// Find the Nth root of a number using binary search

#include<bits/stdc++.h>
int NthRoot(int n, int m) {
  int left =1;
  int right = m;
  while(left<=right){
    long long mid = (left+right)/2;
    if(pow(mid,n)==m){
      return mid;
    }
    else if (pow(mid,n)>m){
      right = mid-1;
    }
    else{
      left = mid+1;
    }
  }
  return -1;
}

// Koko Eating Bananas		
	
class Solution {
public:
    long long getHoursToEatAll(vector<int>&piles, int bananasPerHour){
        long long totalHours = 0;
        for (int i = 0; i < piles.size(); i++){
            int hoursToEatPile = ceil(piles[i] / (double)bananasPerHour);
            totalHours += hoursToEatPile;
        }
        return totalHours;
    }
    int minEatingSpeed(vector<int>& piles, int targetHours){
        int low = 1, high = *(max_element(piles.begin(), piles.end()));
        int ans = -1;
        while(low <= high){
            int mid = low + (high - low) / 2;
            long long hoursToEatAll = getHoursToEatAll(piles, mid);
            if (hoursToEatAll <= targetHours){
                ans = mid;
                high = mid - 1;
            }
            else low = mid + 1;
        }
        return ans;
    }
};

// Minimum days to make M bouquets		

// Coding Ninjas
#include<bits/stdc++.h>
using namespace std;
int mini(vector<int> &arr,int n){
    int ans=INT_MAX;
    for(int i=0;i<n;i++){
        ans= min(ans, arr[i]);
    }
    return ans;
}
int maxi(vector<int> &arr, int n){
    int ans= INT_MIN
    for(int i=0;i<n;i++){
        ans= max(ans, arr[i]);
    }
    return ans;
}
bool func(vector<int> &arr, int n, int k, int h, int mid){
    int total=0;
    int count=0;
    for(int i=0;i<n;i++){
        if(arr[i]<=mid){
            count++;
        }
        else{
            total+=count/k;
            count=0;
        }
    }
    total+=count/k;
    return total>=h;
}
int roseGarden(vector<int> arr, int k, int m){
    int n=arr.size();
    int low=mini(arr, n);
    int high =maxi(arr,n);
    int ans=-1;
    while(low<=high){
        int mid= low+(high-low)/2;
        if(func(arr, n, k ,m,mid)){
            ans= mid;
            high =mid-1;
        }
        else{
            low= mid+1;
        }
    }
    return ans;
}

// Leetcode
// Method-1
class Solution {
public:
    void arrayMinMax(vector<int> &bloomDay,int &minElement,int &maxElement){
        for(int i=0;i<bloomDay.size();i++){
            if(bloomDay[i]<minElement){
                minElement=bloomDay[i];
            }
            if(bloomDay[i]>maxElement){
                maxElement=bloomDay[i];
            }
        }
    }
    bool isPossible(vector<int> &bloomDay,int days,int m,int k){
        int count=0,numOfBouq=0;
        for(int i=0;i<bloomDay.size();i++){
            if(bloomDay[i]<=days){
                count++;
            }
            else{
                numOfBouq+=count/k;
                count=0;
            }
        }
        numOfBouq+=count/k;
        return numOfBouq>=m;
    }
    int minDays(vector<int>& bloomDay, int m, int k) {
        int minDays=INT_MAX,maxDays=INT_MIN;
        arrayMinMax(bloomDay,minDays,maxDays);
        for(int i=minDays;i<=maxDays;i++){
            if(isPossible(bloomDay,i,m,k)){
                return i;
            }
        }
        return -1;
    }
};

// Method-2
class Solution {
public:
    void arrayMinMax(vector<int> &bloomDay,int &minElement,int &maxElement){
        for(int i=0;i<bloomDay.size();i++){
            if(bloomDay[i]<minElement){
                minElement=bloomDay[i];
            }
            if(bloomDay[i]>maxElement){
                maxElement=bloomDay[i];
            }
        }
    }
    bool isPossible(vector<int> &bloomDay,int days,int m,int k){
        int count=0,numOfBouq=0;
        for(int i=0;i<bloomDay.size();i++){
            if(bloomDay[i]<=days){
                count++;
            }
            else{
                numOfBouq+=count/k;
                count=0;
            }
        }
        numOfBouq+=count/k;
        return numOfBouq>=m;
    }
    int minDays(vector<int> &bloomDay,int m,int k){
        // Edge case
        long long val=m*1ll*k*1ll;
        int n=bloomDay.size();
        if(val>n){
            return -1;
        }

        int low=INT_MAX,high=INT_MIN;
        arrayMinMax(bloomDay,low,high);
        while(low<=high){
            int mid=low+(high-low)/2;
            if(isPossible(bloomDay,mid,m,k)){
                high=mid-1;
            }
            else{
                low=mid+1;
            }
        }
        return low;
    }
};

// Find the smallest Divisor		
	
class Solution {
public:
    int SumOfDivisor(vector<int>& nums, int Day){
        int sum = 0;
        for(int i = 0;i<nums.size();i++){
            sum += ceil((double)nums[i]/(double)(Day));
        }
        return sum;
    }
    int smallestDivisor(vector<int>& nums, int threshold) {
        int maxi = INT_MIN;
        for(int i = 0;i<nums.size();i++){
            maxi = max(maxi,nums[i]);
        }
        int low = 1,high = maxi,ans = -1;
        while(low <= high){
            int mid = (low + high)/2;
            if(SumOfDivisor(nums,mid) <= threshold){
                ans = mid;
                high = mid - 1;
            }
            else{
                low = mid + 1;
            }
        }
        return ans;
    }
};

// Capacity to Ship Packages within D Days	
	
bool isPossible(vector<int> &arr, int d,int mid){
    int dayCnt=1;
    int total_weight=0;
    for(int i=0;i<arr.size();i++){
        if(mid>=arr[i] && (total_weight+arr[i])<=mid){
            total_weight+=arr[i];
        }
        else{
            if(mid<arr[i]){
                return false;
            }
            dayCnt++;
            if(dayCnt>d){
                return false;
            }
            total_weight=arr[i];
        }
    }
    return true;
}
int leastWeightCapacity(vector<int> &arr, int d){
    int s=0;
    int e=0;
    int n=arr.size();
    for(int i=0;i<n;i++){
        if(arr[i]<s){
            s=arr[i];
        }
        e+=arr[i];
    }
    int total_weight=e;
    int ans=-1;
    while(s<=e){
        int mid=s+(e-s)/2;
        if(isPossible(arr,d,mid)){
            ans=mid;
            e=mid-1;
        }
        else{
            s=mid+1;
        }
    }
    return ans;
}

// Kth Missing Positive Number		
	
int missingK(vector < int > arr, int n, int k) {
    int low =0;
    int high = n-1;
    while(low<=high){
        int mid= (low+high)/2;
        int missing = arr[mid] - (mid+1);
        if(missing<k){
            low=mid+1;
        }
        else{
            high = mid-1;
        }
    }
    // return low+k;
    return high+1+k;
}

// Aggressive Cows		
	
bool isPossible(vector<int> &stalls, int k, int mid, int n) {
    int cowCount = 1;
    int lastPos = stalls[0];
    for(int i=0; i<n; i++ ){
        if(stalls[i]-lastPos >= mid){
            cowCount++;
            if(cowCount==k){
                return true;
            }
            lastPos = stalls[i];
        }
    }
    return false;
}
int aggressiveCows(vector<int> &stalls, int k){
    sort(stalls.begin(), stalls.end());
   	int s = 0;
    int n = stalls.size();
    int e=stalls[n-1];
    int ans = -1;
    int mid = s + (e-s)/2;
    while(s<=e) {
        if(isPossible(stalls, k, mid, n)) {
            ans = mid;
            s = mid + 1;
        }
        else{
            e = mid - 1;
        }
        mid = s + (e-s)/2;
    }
    return ans;
}

// Book Allocation Problem		
	
bool isPossible(vector<int>& arr, int n, int m, int mid){
    int student = 1;
    int pageSum = 0;
    for(int i = 0; i<n; i++){
        if(pageSum+arr[i] <= mid){
            pageSum += arr[i];
        }
        else{
            student++;
            if(student > m|| arr[i] > mid){
                return false;
            }
            pageSum = arr[i];
        }
    }
    return true;
}
int findPages(vector<int>& arr, int n, int m) {
    if(m>n){
        return -1;
    }
    int s = 0;
    int sum = 0;
    for(int i = 0; i<n; i++){
        sum += arr[i];
    }
    int e = sum;
    int mid = s + (e-s)/2;
    int ans = -1;
    while(s<=e){
        if(isPossible(arr, n, m, mid)){
            ans = mid;
            e = mid - 1;
        }
        else {
            s = mid + 1;
        }
        mid = s + (e-s)/2;
    }
    return ans;
}

// Split array - Largest Sum		
	
int findsubarrayk(vector<int> a, int mid) {
    int sumarray=0;
    int countk=1;
    for(int i=0;i<a.size();i++) {
        if(sumarray+a[i]<=mid) {
            sumarray+=a[i];
        }
        else {
            countk++;
            sumarray=a[i];
        }
    }
    return countk;
}
int largestSubarraySumMinimized(vector<int> a, int k) {
    int low=*max_element(a.begin(),a.end());
    int high=accumulate(a.begin(),a.end(),0);
    while(low<=high) {
        int mid=(low+high)/2;
        int cntk=findsubarrayk(a,mid);
        if(cntk>k){
            low=mid+1;
        }
        else{
            high=mid-1;
        }
    }
    return low;
}

// Painter's partition		



// Minimize Max Distance to Gas Station		
	


// Median of 2 sorted arrays		
	


// Kth element of 2 sorted arrays



/* Step 4.3: BS on 2D Arrays */

// Find the row with maximum number of…		



// Search in a 2D matrix		
	


// Search in a row and column wise sor…		
	


// Find Peak Element (2D Matrix)		
	


// Matrix Median
