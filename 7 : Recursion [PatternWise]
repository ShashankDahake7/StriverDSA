/* Step 7.1: Get a Strong Hold */

// Recursive Implementation of atoi()				

// CN
#include<bits/stdc++.h>

int createAtoi(string s) {
    long long ans=0;
    int count=0;
    int i=0;
    for(;i<s.size();i++){
        if(s[i]=='-' && count==0){
            count++;
            if(!(s[i+1]>=0 && s[i+1]<='9') || s[i+1]=='+'){
                return 0;
            }
        }
        else if(s[i]>='0' && s[i]<='9'){
            ans=ans*10+(s[i]-'0');
            if(ans>INT_MAX){
                if(count>0){
                    return INT_MIN;
                }
                return INT_MAX;
            }
        }
        else if((!(s[i]>='0' && s[i]<='9')) && ans>0){
            break;
        }
    } 
    if(count>0){
        ans=ans*(-1);
    }
    return ans;
}

// LC
class Solution {
public:
    int myAtoi(string s) {
       int i=0; 
       while(i<s.size() && s[i]==' '){
            i++;
       }
       s = s.substr(i,s.size());
       int sign = 1;
       long long ans=0;
       if(s[0]=='-'){
           sign=-1;
       }
       int MAX=INT_MAX, MIN=INT_MIN;
       i = (s[0]=='-' || s[0]=='+') ? 1 : 0;
       while(i<s.size()){
          if(s[i]==' ' || !isdigit(s[i])){
              break;
          }
          ans= ans * 10 + s[i] - '0';
          if(sign==-1 && sign*ans<MIN){
              return MIN;
          }
          if(sign==1 && ans>MAX){
              return MAX;
          }
          i++;
       }
       return (int)sign * ans;
    }
};

// Pow(x, n)		
	
class Solution {
public:
    double myPow(double x, int n) {
        if(n==0){
            return 1.0;
        }
        if(n==1){
            return x;
        }
        if(n==-1){
            return 1/x;
        }
        double half=myPow(x,n/2);
        double res=half*half;
        if(n%2!=0){
            res=(n>0)?res*x:res/x;
        }
        return res;
    }
};

// Count Good numbers				



// Sort a stack using recursion				



// Reverse a stack using recursion



/* Step 7.2: Subsequences Pattern */

// Generate all binary strings				



// Generate Paranthesis				



// Print all subsequences/Power Set		
	


// Learn All Patterns of Subsequences (Theory)		



// Count all subsequences with sum K				



// Check if there exists a subsequence with sum K			



// Combination Sum		
	


// Combination Sum-II		
	


// Subset Sum-I		



// Subset Sum-II		
	


// Combination Sum - III				



// Letter Combinations of a Phone number



/* Step 7.3: Trying out all Combos / Hard */

// Palindrome Partitioning		
	


// Word Search				



// N Queen		
	


// Rat in a Maze		



// Word Break				



// M Coloring Problem		
	


// Sudoko Solver		
	


// Expression Add Operators
